
//----------------------------------------------------
// The following code was generated by CUP v0.10g
// Mon Oct 14 08:29:03 MDT 2002
//----------------------------------------------------

package geomdir.applied;

import java_cup.runtime.*;
import meta.*;
import geomdir.*;

public class EXparser extends java_cup.runtime.lr_parser {

  /** constructor */
  public EXparser() {super();}

  /** production table */
  protected static final short _production_table[][] = {
        {1, 1},     {0, 2},     {1, 1},     {3, 1},     {3, 1}, 
        {4, 3},     {4, 3},     {4, 3},     {4, 2},     {4, 3}, 
        {4, 2},     {4, 2},     {4, 3},     {5, 5},     {2, 3}, 
        {2, 2},     {2, 3},     {2, 2},     {2, 3},     {2, 2}, 
        {2, 3},     {2, 2},     {2, 3},     {2, 2},     {2, 3}, 
        {2, 2},     {2, 3},     {2, 2},     {2, 3},     {2, 2}, 
        {2, 3},     {2, 2},     {2, 2},     {2, 2},     {2, 2}, 
        {2, 2},     {2, 2},     {2, 2},     {2, 2},     {2, 2}, 
        {2, 2},     {2, 2},     {2, 2},     {2, 2},     {2, 3}, 
        {2, 2},     {2, 2},     {2, 2},     {2, 2},     {2, 1}, 
        {2, 1},     {6, 2},     {7, 1},     {7, 1},     {7, 3}, 
        {8, 1},     {8, 1},     {8, 0},     {9, 3},     {9, 1}, 
        {9, 3},     {9, 3},     {9, 2},     {9, 3},     {9, 2}, 
        {9, 2},     {9, 3},     {9, 2},     {9, 2},     {10, 1}, 
        {10, 2},     {10, 3},     {10, 4},     {10, 5},     {11, 1}, 
        {11, 0},     {14, 3},     {14, 2},     {14, 3},     {14, 2}, 
        {14, 3},     {14, 2},     {14, 3},     {14, 2},     {14, 3}, 
        {14, 2},     {14, 3},     {14, 2},     {14, 3},     {14, 2}, 
        {14, 3},     {14, 2},     {14, 3},     {14, 2},     {14, 2}, 
        {14, 2},     {14, 2},     {14, 2},     {14, 2},     {14, 2}, 
        {14, 2},     {14, 3},     {14, 2},     {14, 2},     {14, 2}, 
        {14, 2},     {15, 1},     {15, 0},     {12, 1},     {12, 2}, 
        {13, 1},     {13, 0},     {16, 3},     {16, 2},     {16, 2}, 
        {17, 1},     {17, 0},     {18, 2},     {18, 4},     {18, 3}, 
        {19, 2},     {19, 0}  };

  /** access to production table */
  public short[][] production_table() {return _production_table;}

  /** parse action table */
  protected static final short[][] _action_table = {
    /*0*/{0,-58,2,30,3,2,4,11,5,16,6,15,9,31,11,7,12,4,13,32,14,33,15,8,18,28,19,27,20,20,21,34,22,12,23,26,24,35,25,13,26,3,27,21,28,10,29,22,30,5,31,24,33,19,-1,0},
    /*1*/{0,-108,2,30,3,2,4,11,5,16,6,15,9,47,10,-108,11,7,12,4,13,32,14,33,15,8,18,28,19,46,20,20,21,34,22,12,27,21,28,10,29,22,30,5,31,24,33,19,-1,0},
    /*2*/{0,-76,9,42,10,-76,19,39,33,43,-1,0},
    /*3*/{0,-108,2,30,3,2,4,11,5,16,6,15,9,47,10,-108,11,7,12,4,13,32,14,33,15,8,18,28,19,46,20,20,21,34,22,12,27,21,28,10,29,22,30,5,31,24,33,19,-1,0},
    /*4*/{0,-112,9,42,10,-112,19,39,33,43,-1,0},
    /*5*/{0,-56,-1,0},
    /*6*/{0,-108,2,30,3,2,4,11,5,16,6,15,9,47,10,-108,11,7,12,4,13,32,14,33,15,8,18,28,19,46,20,20,21,34,22,12,27,21,28,10,29,22,30,5,31,24,33,19,-1,0},
    /*7*/{0,-108,2,30,3,2,4,11,5,16,6,15,9,47,10,-108,11,7,12,4,13,32,14,33,15,8,18,28,19,46,20,20,21,34,22,12,27,21,28,10,29,22,30,5,31,24,33,19,-1,0},
    /*8*/{0,-1,-1,0},
    /*9*/{0,-108,2,30,3,2,4,11,5,16,6,15,9,47,10,-108,11,7,12,4,13,32,14,33,15,8,18,28,19,46,20,20,21,34,22,12,27,21,28,10,29,22,30,5,31,24,33,19,-1,0},
    /*10*/{0,-112,9,42,10,-112,19,39,33,43,-1,0},
    /*11*/{0,-112,9,42,10,-112,19,39,33,43,-1,0},
    /*12*/{0,-112,9,42,10,-112,19,39,33,43,-1,0},
    /*13*/{0,-4,2,63,3,61,4,64,5,56,6,58,11,59,12,62,15,60,20,69,21,68,22,54,24,104,25,103,27,66,28,57,29,55,30,65,31,67,-1,0},
    /*14*/{0,-112,9,42,10,-112,19,39,33,43,-1,0},
    /*15*/{0,-112,9,42,10,-112,19,39,33,43,-1,0},
    /*16*/{0,-50,2,-50,3,-50,4,-50,5,-50,6,-50,10,-50,11,-50,12,-50,15,-50,20,-50,21,-50,22,-50,24,-50,25,-50,27,-50,28,-50,29,-50,30,-50,31,-50,-1,0},
    /*17*/{0,-57,-1,0},
    /*18*/{0,-122,2,-122,3,-122,4,-122,5,-122,6,-122,10,-122,11,-122,12,-122,15,-122,18,-122,20,-122,21,-122,22,-122,24,-122,25,-122,27,-122,28,-122,29,-122,30,-122,31,-122,33,114,-1,0},
    /*19*/{0,-108,2,30,3,2,4,11,5,16,6,15,9,47,10,-108,11,7,12,4,13,32,14,33,15,8,18,28,19,46,20,20,21,34,22,12,27,21,28,10,29,22,30,5,31,24,33,19,-1,0},
    /*20*/{0,-108,2,30,3,2,4,11,5,16,6,15,9,47,10,-108,11,7,12,4,13,32,14,33,15,8,18,28,19,46,20,20,21,34,22,12,27,21,28,10,29,22,30,5,31,24,33,19,-1,0},
    /*21*/{0,-112,9,42,10,-112,19,39,33,43,-1,0},
    /*22*/{0,-3,-1,0},
    /*23*/{0,-112,9,42,10,-112,19,39,33,43,-1,0},
    /*24*/{0,-5,-1,0},
    /*25*/{0,-60,10,-60,19,119,-1,0},
    /*26*/{0,-51,2,-51,3,-51,4,-51,5,-51,6,-51,10,-51,11,-51,12,-51,15,-51,20,-51,21,-51,22,-51,23,116,24,-51,25,-51,27,-51,28,-51,29,-51,30,-51,31,-51,-1,0},
    /*27*/{33,112,-1,0},
    /*28*/{0,111,-1,0},
    /*29*/{0,-108,2,30,3,2,4,11,5,16,6,15,9,47,10,-108,11,7,12,4,13,32,14,33,15,8,18,28,19,46,20,20,21,34,22,12,27,21,28,10,29,22,30,5,31,24,33,19,-1,0},
    /*30*/{0,-108,2,30,3,2,4,11,5,16,6,15,9,31,10,-108,11,7,12,4,13,32,14,33,15,8,18,28,19,27,20,20,21,34,22,12,23,26,24,35,25,13,26,3,27,21,28,10,29,22,30,5,31,24,33,19,-1,0},
    /*31*/{0,-112,9,42,10,-112,19,39,33,43,-1,0},
    /*32*/{0,-112,9,42,10,-112,19,39,33,43,-1,0},
    /*33*/{0,-108,2,30,3,2,4,11,5,16,6,15,9,47,10,-108,11,7,12,4,13,32,14,33,15,8,18,28,19,46,20,20,21,34,22,12,27,21,28,10,29,22,30,5,31,24,33,19,-1,0},
    /*34*/{0,-112,9,42,10,-112,19,39,33,43,-1,0},
    /*35*/{0,-9,10,-9,-1,0},
    /*36*/{0,-111,10,-111,-1,0},
    /*37*/{0,-63,10,-63,-1,0},
    /*38*/{0,-53,2,-53,3,-53,4,-53,5,-53,6,-53,9,-53,10,-53,11,-53,12,-53,15,-53,19,-53,20,-53,21,-53,22,-53,24,-53,25,-53,27,-53,28,-53,29,-53,30,-53,31,-53,33,-53,-1,0},
    /*39*/{0,-117,9,42,10,-117,19,39,33,43,-1,0},
    /*40*/{0,-109,10,-109,-1,0},
    /*41*/{0,-108,2,30,3,2,4,11,5,16,6,15,9,47,10,-108,11,7,12,4,13,32,14,33,15,8,18,28,19,46,20,20,21,34,22,12,27,21,28,10,29,22,30,5,31,24,33,19,-1,0},
    /*42*/{0,-54,2,-54,3,-54,4,-54,5,-54,6,-54,9,-54,10,-54,11,-54,12,-54,15,-54,19,-54,20,-54,21,-54,22,-54,24,-54,25,-54,27,-54,28,-54,29,-54,30,-54,31,-54,33,-54,-1,0},
    /*43*/{0,-107,10,-107,-1,0},
    /*44*/{0,-115,2,63,3,61,4,64,5,56,6,58,10,88,11,59,12,62,15,60,20,69,21,68,22,54,27,66,28,57,29,55,30,65,31,67,-1,0},
    /*45*/{0,-51,2,-51,3,-51,4,-51,5,-51,6,-51,10,-51,11,-51,12,-51,15,-51,20,-51,21,-51,22,-51,24,-51,25,-51,27,-51,28,-51,29,-51,30,-51,31,-51,-1,0},
    /*46*/{0,-108,2,30,3,2,4,11,5,16,6,15,9,47,10,-108,11,7,12,4,13,32,14,33,15,8,18,28,19,46,20,20,21,34,22,12,27,21,28,10,29,22,30,5,31,24,33,19,-1,0},
    /*47*/{0,-114,10,49,-1,0},
    /*48*/{0,-113,10,-113,-1,0},
    /*49*/{0,-104,2,63,3,61,4,64,5,56,6,58,10,53,11,59,12,62,15,60,20,69,21,68,22,54,27,66,28,57,29,55,30,65,31,67,-1,0},
    /*50*/{0,-103,10,52,-1,0},
    /*51*/{0,-102,10,-102,-1,0},
    /*52*/{0,-45,2,-45,3,-45,4,-45,5,-45,6,-45,10,-45,11,-45,12,-45,15,-45,20,-45,21,-45,22,-45,24,-45,25,-45,27,-45,28,-45,29,-45,30,-45,31,-45,-1,0},
    /*53*/{0,-108,2,30,3,2,4,11,5,16,6,15,9,47,10,-108,11,7,12,4,13,32,14,33,15,8,18,28,19,46,20,20,21,34,22,12,27,21,28,10,29,22,30,5,31,24,33,19,-1,0},
    /*54*/{0,-108,2,30,3,2,4,11,5,16,6,15,9,47,10,-108,11,7,12,4,13,32,14,33,15,8,18,28,19,46,20,20,21,34,22,12,27,21,28,10,29,22,30,5,31,24,33,19,-1,0},
    /*55*/{0,-108,2,30,3,2,4,11,5,16,6,15,9,47,10,-108,11,7,12,4,13,32,14,33,15,8,18,28,19,46,20,20,21,34,22,12,27,21,28,10,29,22,30,5,31,24,33,19,-1,0},
    /*56*/{0,-44,2,-44,3,-44,4,-44,5,-44,6,-44,10,-44,11,-44,12,-44,15,-44,20,-44,21,-44,22,-44,24,-44,25,-44,27,-44,28,-44,29,-44,30,-44,31,-44,-1,0},
    /*57*/{0,-108,2,30,3,2,4,11,5,16,6,15,9,47,10,-108,11,7,12,4,13,32,14,33,15,8,18,28,19,46,20,20,21,34,22,12,27,21,28,10,29,22,30,5,31,24,33,19,-1,0},
    /*58*/{0,-47,2,-47,3,-47,4,-47,5,-47,6,-47,10,-47,11,-47,12,-47,15,-47,20,-47,21,-47,22,-47,24,-47,25,-47,27,-47,28,-47,29,-47,30,-47,31,-47,-1,0},
    /*59*/{0,-49,2,-49,3,-49,4,-49,5,-49,6,-49,10,-49,11,-49,12,-49,15,-49,20,-49,21,-49,22,-49,24,-49,25,-49,27,-49,28,-49,29,-49,30,-49,31,-49,-1,0},
    /*60*/{0,-108,2,30,3,2,4,11,5,16,6,15,9,47,10,-108,11,7,12,4,13,32,14,33,15,8,18,28,19,46,20,20,21,34,22,12,27,21,28,10,29,22,30,5,31,24,33,19,-1,0},
    /*61*/{0,-38,2,-38,3,-38,4,-38,5,-38,6,-38,10,-38,11,-38,12,-38,15,-38,20,-38,21,-38,22,-38,24,-38,25,-38,27,-38,28,-38,29,-38,30,-38,31,-38,-1,0},
    /*62*/{0,-108,2,30,3,2,4,11,5,16,6,15,9,47,10,-108,11,7,12,4,13,32,14,33,15,8,18,28,19,46,20,20,21,34,22,12,27,21,28,10,29,22,30,5,31,24,33,19,-1,0},
    /*63*/{0,-108,2,30,3,2,4,11,5,16,6,15,9,47,10,-108,11,7,12,4,13,32,14,33,15,8,18,28,19,46,20,20,21,34,22,12,27,21,28,10,29,22,30,5,31,24,33,19,-1,0},
    /*64*/{0,-108,2,30,3,2,4,11,5,16,6,15,9,47,10,-108,11,7,12,4,13,32,14,33,15,8,18,28,19,46,20,20,21,34,22,12,27,21,28,10,29,22,30,5,31,24,33,19,-1,0},
    /*65*/{0,-42,2,-42,3,-42,4,-42,5,-42,6,-42,10,-42,11,-42,12,-42,15,-42,20,-42,21,-42,22,-42,24,-42,25,-42,27,-42,28,-42,29,-42,30,-42,31,-42,-1,0},
    /*66*/{0,-108,2,30,3,2,4,11,5,16,6,15,9,47,10,-108,11,7,12,4,13,32,14,33,15,8,18,28,19,46,20,20,21,34,22,12,27,21,28,10,29,22,30,5,31,24,33,19,-1,0},
    /*67*/{0,-40,2,-40,3,-40,4,-40,5,-40,6,-40,10,-40,11,-40,12,-40,15,-40,20,-40,21,-40,22,-40,24,-40,25,-40,27,-40,28,-40,29,-40,30,-40,31,-40,-1,0},
    /*68*/{0,-36,2,-36,3,-36,4,-36,5,-36,6,-36,10,-36,11,-36,12,-36,15,-36,20,-36,21,-36,22,-36,24,-36,25,-36,27,-36,28,-36,29,-36,30,-36,31,-36,-1,0},
    /*69*/{0,-31,2,-31,3,-31,4,-31,5,-31,6,-31,10,-31,11,59,12,62,15,60,20,69,21,68,22,54,24,-31,25,-31,27,66,28,57,29,-31,30,-31,31,-31,-1,0},
    /*70*/{0,-93,10,-93,-1,0},
    /*71*/{0,-29,2,-29,3,-29,4,-29,5,-29,6,-29,10,-29,11,59,12,62,15,60,20,69,21,68,22,54,24,-29,25,-29,27,66,28,57,29,-29,30,-29,31,67,-1,0},
    /*72*/{0,-91,10,-91,-1,0},
    /*73*/{0,-19,2,-19,3,-19,4,-19,5,-19,6,-19,10,-19,11,59,12,62,15,60,20,69,21,68,22,54,24,-19,25,-19,27,66,28,57,29,55,30,65,31,67,-1,0},
    /*74*/{0,-81,10,-81,-1,0},
    /*75*/{0,-15,2,-15,3,-15,4,64,5,56,6,58,10,-15,11,59,12,62,15,60,20,69,21,68,22,54,24,-15,25,-15,27,66,28,57,29,55,30,65,31,67,-1,0},
    /*76*/{0,-77,10,-77,-1,0},
    /*77*/{0,-17,2,-17,3,-17,4,64,5,56,6,58,10,-17,11,59,12,62,15,60,20,69,21,68,22,54,24,-17,25,-17,27,66,28,57,29,55,30,65,31,67,-1,0},
    /*78*/{0,-79,10,-79,-1,0},
    /*79*/{0,-23,2,-23,3,-23,4,-23,5,-23,6,-23,10,-23,11,59,12,62,15,60,20,69,21,68,22,54,24,-23,25,-23,27,66,28,57,29,55,30,65,31,67,-1,0},
    /*80*/{0,-85,10,-85,-1,0},
    /*81*/{0,-21,2,-21,3,-21,4,-21,5,-21,6,-21,10,-21,11,59,12,62,15,60,20,69,21,68,22,54,24,-21,25,-21,27,66,28,57,29,55,30,65,31,67,-1,0},
    /*82*/{0,-83,10,-83,-1,0},
    /*83*/{0,-27,2,-27,3,-27,4,-27,5,-27,6,-27,10,-27,11,59,12,62,15,60,20,69,21,68,22,54,24,-27,25,-27,27,66,28,57,29,-27,30,65,31,67,-1,0},
    /*84*/{0,-89,10,-89,-1,0},
    /*85*/{0,-25,2,-25,3,-25,4,-25,5,-25,6,-25,10,-25,11,59,12,62,15,60,20,69,21,68,22,54,24,-25,25,-25,27,66,28,57,29,-25,30,-25,31,-25,-1,0},
    /*86*/{0,-87,10,-87,-1,0},
    /*87*/{0,-55,2,-55,3,-55,4,-55,5,-55,6,-55,9,-55,10,-55,11,-55,12,-55,15,-55,19,-55,20,-55,21,-55,22,-55,24,-55,25,-55,27,-55,28,-55,29,-55,30,-55,31,-55,33,-55,-1,0},
    /*88*/{0,-52,2,-52,3,-52,4,-52,5,-52,6,-52,10,-52,11,-52,12,-52,15,-52,20,-52,21,-52,22,-52,24,-52,25,-52,27,-52,28,-52,29,-52,30,-52,31,-52,-1,0},
    /*89*/{0,-110,10,-110,-1,0},
    /*90*/{0,-116,10,-116,-1,0},
    /*91*/{0,-39,2,-39,3,-39,4,-39,5,-39,6,-39,10,-39,11,-39,12,-39,15,-39,20,-39,21,-39,22,-39,24,-39,25,-39,27,-39,28,-39,29,-39,30,-39,31,-39,-1,0},
    /*92*/{0,-99,10,-99,-1,0},
    /*93*/{0,-18,2,-18,3,-18,4,-18,5,-18,6,-18,10,-18,11,-18,12,-18,15,-18,20,-18,21,-18,22,-18,24,-18,25,-18,27,-18,28,-18,29,-18,30,-18,31,-18,-1,0},
    /*94*/{0,-80,10,-80,-1,0},
    /*95*/{0,-16,2,-16,3,-16,4,-16,5,-16,6,-16,10,-16,11,-16,12,-16,15,-16,20,-16,21,-16,22,-16,24,-16,25,-16,27,-16,28,-16,29,-16,30,-16,31,-16,-1,0},
    /*96*/{0,-78,10,-78,-1,0},
    /*97*/{0,-104,2,63,3,61,4,64,5,56,6,58,10,53,11,59,12,62,15,60,20,69,21,68,22,54,24,104,25,103,27,66,28,57,29,55,30,65,31,67,-1,0},
    /*98*/{0,-68,10,102,-1,0},
    /*99*/{0,-69,10,101,-1,0},
    /*100*/{0,-13,10,-13,-1,0},
    /*101*/{0,-67,10,-67,-1,0},
    /*102*/{0,-108,2,30,3,2,4,11,5,16,6,15,9,47,10,-108,11,7,12,4,13,32,14,33,15,8,18,28,19,46,20,20,21,34,22,12,27,21,28,10,29,22,30,5,31,24,33,19,-1,0},
    /*103*/{0,-108,2,30,3,2,4,11,5,16,6,15,9,47,10,-108,11,7,12,4,13,32,14,33,15,8,18,28,19,46,20,20,21,34,22,12,27,21,28,10,29,22,30,5,31,24,33,19,-1,0},
    /*104*/{0,-8,2,63,3,61,4,64,5,56,6,58,10,-8,11,59,12,62,15,60,20,69,21,68,22,54,27,66,28,57,29,55,30,65,31,67,-1,0},
    /*105*/{0,-62,10,-62,-1,0},
    /*106*/{0,-10,2,63,3,61,4,64,5,56,6,58,10,-10,11,59,12,62,15,60,20,69,21,68,22,54,27,66,28,57,29,55,30,65,31,67,-1,0},
    /*107*/{0,-64,10,-64,-1,0},
    /*108*/{0,-33,2,-33,3,-33,4,-33,5,-33,6,-33,10,-33,11,-33,12,-33,15,-33,20,-33,21,-33,22,-33,24,-33,25,-33,27,-33,28,-33,29,-33,30,-33,31,-33,-1,0},
    /*109*/{0,-95,10,-95,-1,0},
    /*110*/{0,-2,-1,0},
    /*111*/{0,-122,2,-122,3,-122,4,-122,5,-122,6,-122,10,-122,11,-122,12,-122,15,-122,20,-122,21,-122,22,-122,24,-122,25,-122,27,-122,28,-122,29,-122,30,-122,31,-122,33,114,-1,0},
    /*112*/{0,-120,2,-120,3,-120,4,-120,5,-120,6,-120,10,-120,11,-120,12,-120,15,-120,20,-120,21,-120,22,-120,24,-120,25,-120,27,-120,28,-120,29,-120,30,-120,31,-120,-1,0},
    /*113*/{0,-122,2,-122,3,-122,4,-122,5,-122,6,-122,10,-122,11,-122,12,-122,15,-122,18,-122,20,-122,21,-122,22,-122,24,-122,25,-122,27,-122,28,-122,29,-122,30,-122,31,-122,33,114,-1,0},
    /*114*/{0,-121,2,-121,3,-121,4,-121,5,-121,6,-121,10,-121,11,-121,12,-121,15,-121,18,-121,20,-121,21,-121,22,-121,24,-121,25,-121,27,-121,28,-121,29,-121,30,-121,31,-121,-1,0},
    /*115*/{0,-108,2,30,3,2,4,11,5,16,6,15,9,47,10,-108,11,7,12,4,13,32,14,33,15,8,18,28,19,46,20,20,21,34,22,12,27,21,28,10,29,22,30,5,31,24,33,19,-1,0},
    /*116*/{0,-6,2,63,3,61,4,64,5,56,6,58,10,-6,11,59,12,62,15,60,20,69,21,68,22,54,27,66,28,57,29,55,30,65,31,67,-1,0},
    /*117*/{0,-59,10,-59,-1,0},
    /*118*/{0,-108,2,30,3,2,4,11,5,16,6,15,9,47,10,-108,11,7,12,4,13,32,14,33,15,8,18,28,19,46,20,20,21,34,22,12,27,21,28,10,29,22,30,5,31,24,33,19,-1,0},
    /*119*/{0,-7,2,63,3,61,4,64,5,56,6,58,10,-7,11,59,12,62,15,60,20,69,21,68,22,54,27,66,28,57,29,55,30,65,31,67,-1,0},
    /*120*/{0,-61,10,-61,-1,0},
    /*121*/{0,-32,2,-32,3,-32,4,-32,5,-32,6,-32,10,-32,11,-32,12,-32,15,-32,20,-32,21,-32,22,-32,24,-32,25,-32,27,-32,28,-32,29,-32,30,-32,31,-32,-1,0},
    /*122*/{0,-94,10,-94,-1,0},
    /*123*/{0,-28,2,-28,3,-28,4,-28,5,-28,6,-28,10,-28,11,-28,12,-28,15,-28,20,-28,21,-28,22,-28,24,-28,25,-28,27,-28,28,-28,29,-28,30,-28,31,-28,-1,0},
    /*124*/{0,-90,10,-90,-1,0},
    /*125*/{0,-41,2,-41,3,-41,4,-41,5,-41,6,-41,10,-41,11,-41,12,-41,15,-41,20,-41,21,-41,22,-41,24,-41,25,-41,27,-41,28,-41,29,-41,30,-41,31,-41,-1,0},
    /*126*/{0,-100,10,-100,-1,0},
    /*127*/{0,-35,2,-35,3,-35,4,-35,5,-35,6,-35,10,-35,11,-35,12,-35,15,-35,20,-35,21,-35,22,-35,24,-35,25,-35,27,-35,28,-35,29,-35,30,-35,31,-35,-1,0},
    /*128*/{0,-97,10,-97,-1,0},
    /*129*/{0,-118,2,-118,3,-118,4,-118,5,-118,6,-118,10,-118,11,-118,12,-118,15,-118,18,131,20,-118,21,-118,22,-118,24,-118,25,-118,27,-118,28,-118,29,-118,30,-118,31,-118,-1,0},
    /*130*/{0,-122,2,-122,3,-122,4,-122,5,-122,6,-122,10,-122,11,-122,12,-122,15,-122,20,-122,21,-122,22,-122,24,-122,25,-122,27,-122,28,-122,29,-122,30,-122,31,-122,33,114,-1,0},
    /*131*/{0,-119,2,-119,3,-119,4,-119,5,-119,6,-119,10,-119,11,-119,12,-119,15,-119,20,-119,21,-119,22,-119,24,-119,25,-119,27,-119,28,-119,29,-119,30,-119,31,-119,-1,0},
    /*132*/{0,-22,2,-22,3,-22,4,-22,5,-22,6,-22,10,-22,11,-22,12,-22,15,-22,20,-22,21,-22,22,-22,24,-22,25,-22,27,-22,28,-22,29,-22,30,-22,31,-22,-1,0},
    /*133*/{0,-84,10,-84,-1,0},
    /*134*/{0,-24,2,-24,3,-24,4,-24,5,-24,6,-24,10,-24,11,-24,12,-24,15,-24,20,-24,21,-24,22,-24,24,-24,25,-24,27,-24,28,-24,29,-24,30,-24,31,-24,-1,0},
    /*135*/{0,-86,10,-86,-1,0},
    /*136*/{0,-11,10,-11,-1,0},
    /*137*/{0,-65,10,-65,-1,0},
    /*138*/{0,-26,2,-26,3,-26,4,-26,5,-26,6,-26,10,-26,11,-26,12,-26,15,-26,20,-26,21,-26,22,-26,24,-26,25,-26,27,-26,28,-26,29,-26,30,-26,31,-26,-1,0},
    /*139*/{0,-88,10,-88,-1,0},
    /*140*/{0,-20,2,-20,3,-20,4,-20,5,-20,6,-20,10,-20,11,-20,12,-20,15,-20,20,-20,21,-20,22,-20,24,-20,25,-20,27,-20,28,-20,29,-20,30,-20,31,-20,-1,0},
    /*141*/{0,-82,10,-82,-1,0},
    /*142*/{0,-43,2,-43,3,-43,4,-43,5,-43,6,-43,10,-43,11,-43,12,-43,15,-43,20,-43,21,-43,22,-43,24,-43,25,-43,27,-43,28,-43,29,-43,30,-43,31,-43,-1,0},
    /*143*/{0,-101,10,-101,-1,0},
    /*144*/{0,-48,2,-48,3,-48,4,-48,5,-48,6,-48,10,-48,11,-48,12,-48,15,-48,20,-48,21,-48,22,-48,24,-48,25,-48,27,-48,28,-48,29,-48,30,-48,31,-48,-1,0},
    /*145*/{0,-106,10,-106,-1,0},
    /*146*/{0,-46,2,-46,3,-46,4,-46,5,-46,6,-46,10,-46,11,-46,12,-46,15,-46,20,-46,21,-46,22,-46,24,-46,25,-46,27,-46,28,-46,29,-46,30,-46,31,-46,-1,0},
    /*147*/{0,-105,10,-105,-1,0},
    /*148*/{0,-30,2,-30,3,-30,4,-30,5,-30,6,-30,10,-30,11,-30,12,-30,15,-30,20,-30,21,-30,22,-30,24,-30,25,-30,27,-30,28,-30,29,-30,30,-30,31,-30,-1,0},
    /*149*/{0,-92,10,-92,-1,0},
    /*150*/{0,-37,2,-37,3,-37,4,-37,5,-37,6,-37,10,-37,11,-37,12,-37,15,-37,20,-37,21,-37,22,-37,24,-37,25,-37,27,-37,28,-37,29,-37,30,-37,31,-37,-1,0},
    /*151*/{0,-98,10,-98,-1,0},
    /*152*/{0,-117,9,42,10,-117,19,39,33,43,-1,0},
    /*153*/{0,-75,10,-75,-1,0},
    /*154*/{0,-70,10,-70,-1,0},
    /*155*/{0,-12,10,-12,-1,0},
    /*156*/{0,-66,10,-66,-1,0},
    /*157*/{0,-117,9,42,10,-117,19,39,33,43,-1,0},
    /*158*/{0,-71,10,-71,-1,0},
    /*159*/{0,-117,9,42,10,-117,19,39,33,43,-1,0},
    /*160*/{0,-72,10,-72,-1,0},
    /*161*/{0,-117,9,42,10,-117,19,39,33,43,-1,0},
    /*162*/{0,-73,10,-73,-1,0},
    /*163*/{0,-14,10,-14,-1,0},
    /*164*/{0,-74,10,-74,-1,0},
    /*165*/{0,-34,2,-34,3,-34,4,-34,5,-34,6,-34,10,-34,11,-34,12,-34,15,-34,20,-34,21,-34,22,-34,24,-34,25,-34,27,-34,28,-34,29,-34,30,-34,31,-34,-1,0},
    /*166*/{0,-96,10,-96,-1,0},
  };

  /** access to parse action table */
  public short[][] action_table() {return _action_table;}

  /** reduce_goto table */
  protected static final short[][] _reduce_table = {
    /*0*/{1,28,2,13,3,8,4,24,8,22,9,17,14,5,18,16,-1,-1},
    /*1*/{2,165,14,43,15,166,18,16,-1,-1},
    /*2*/{5,155,7,152,10,153,11,156,16,154,-1,-1},
    /*3*/{2,150,14,43,15,151,18,16,-1,-1},
    /*4*/{6,148,7,39,12,36,13,149,16,40,-1,-1},
    /*5*/{-1,-1},
    /*6*/{2,146,14,43,15,147,18,16,-1,-1},
    /*7*/{2,144,14,43,15,145,18,16,-1,-1},
    /*8*/{-1,-1},
    /*9*/{2,142,14,43,15,143,18,16,-1,-1},
    /*10*/{6,140,7,39,12,36,13,141,16,40,-1,-1},
    /*11*/{6,138,7,39,12,36,13,139,16,40,-1,-1},
    /*12*/{6,136,7,39,12,36,13,137,16,40,-1,-1},
    /*13*/{-1,-1},
    /*14*/{6,134,7,39,12,36,13,135,16,40,-1,-1},
    /*15*/{6,132,7,39,12,36,13,133,16,40,-1,-1},
    /*16*/{-1,-1},
    /*17*/{-1,-1},
    /*18*/{19,129,-1,-1},
    /*19*/{2,127,14,43,15,128,18,16,-1,-1},
    /*20*/{2,125,14,43,15,126,18,16,-1,-1},
    /*21*/{6,123,7,39,12,36,13,124,16,40,-1,-1},
    /*22*/{-1,-1},
    /*23*/{6,121,7,39,12,36,13,122,16,40,-1,-1},
    /*24*/{-1,-1},
    /*25*/{-1,-1},
    /*26*/{-1,-1},
    /*27*/{-1,-1},
    /*28*/{-1,-1},
    /*29*/{2,108,14,43,15,109,18,16,-1,-1},
    /*30*/{2,97,4,99,9,98,14,43,15,50,18,16,-1,-1},
    /*31*/{6,95,7,39,12,36,13,96,16,40,-1,-1},
    /*32*/{6,93,7,39,12,36,13,94,16,40,-1,-1},
    /*33*/{2,91,14,43,15,92,18,16,-1,-1},
    /*34*/{6,35,7,39,12,36,13,37,16,40,-1,-1},
    /*35*/{-1,-1},
    /*36*/{-1,-1},
    /*37*/{-1,-1},
    /*38*/{-1,-1},
    /*39*/{7,88,16,90,17,89,-1,-1},
    /*40*/{-1,-1},
    /*41*/{2,44,14,43,15,47,18,16,-1,-1},
    /*42*/{-1,-1},
    /*43*/{-1,-1},
    /*44*/{-1,-1},
    /*45*/{-1,-1},
    /*46*/{2,49,14,43,15,50,18,16,-1,-1},
    /*47*/{-1,-1},
    /*48*/{-1,-1},
    /*49*/{-1,-1},
    /*50*/{-1,-1},
    /*51*/{-1,-1},
    /*52*/{-1,-1},
    /*53*/{2,85,14,43,15,86,18,16,-1,-1},
    /*54*/{2,83,14,43,15,84,18,16,-1,-1},
    /*55*/{2,81,14,43,15,82,18,16,-1,-1},
    /*56*/{-1,-1},
    /*57*/{2,79,14,43,15,80,18,16,-1,-1},
    /*58*/{-1,-1},
    /*59*/{-1,-1},
    /*60*/{2,77,14,43,15,78,18,16,-1,-1},
    /*61*/{-1,-1},
    /*62*/{2,75,14,43,15,76,18,16,-1,-1},
    /*63*/{2,73,14,43,15,74,18,16,-1,-1},
    /*64*/{2,71,14,43,15,72,18,16,-1,-1},
    /*65*/{-1,-1},
    /*66*/{2,69,14,43,15,70,18,16,-1,-1},
    /*67*/{-1,-1},
    /*68*/{-1,-1},
    /*69*/{-1,-1},
    /*70*/{-1,-1},
    /*71*/{-1,-1},
    /*72*/{-1,-1},
    /*73*/{-1,-1},
    /*74*/{-1,-1},
    /*75*/{-1,-1},
    /*76*/{-1,-1},
    /*77*/{-1,-1},
    /*78*/{-1,-1},
    /*79*/{-1,-1},
    /*80*/{-1,-1},
    /*81*/{-1,-1},
    /*82*/{-1,-1},
    /*83*/{-1,-1},
    /*84*/{-1,-1},
    /*85*/{-1,-1},
    /*86*/{-1,-1},
    /*87*/{-1,-1},
    /*88*/{-1,-1},
    /*89*/{-1,-1},
    /*90*/{-1,-1},
    /*91*/{-1,-1},
    /*92*/{-1,-1},
    /*93*/{-1,-1},
    /*94*/{-1,-1},
    /*95*/{-1,-1},
    /*96*/{-1,-1},
    /*97*/{-1,-1},
    /*98*/{-1,-1},
    /*99*/{-1,-1},
    /*100*/{-1,-1},
    /*101*/{-1,-1},
    /*102*/{2,106,14,43,15,107,18,16,-1,-1},
    /*103*/{2,104,14,43,15,105,18,16,-1,-1},
    /*104*/{-1,-1},
    /*105*/{-1,-1},
    /*106*/{-1,-1},
    /*107*/{-1,-1},
    /*108*/{-1,-1},
    /*109*/{-1,-1},
    /*110*/{-1,-1},
    /*111*/{19,112,-1,-1},
    /*112*/{-1,-1},
    /*113*/{19,114,-1,-1},
    /*114*/{-1,-1},
    /*115*/{2,116,14,43,15,117,18,16,-1,-1},
    /*116*/{-1,-1},
    /*117*/{-1,-1},
    /*118*/{2,119,14,43,15,120,18,16,-1,-1},
    /*119*/{-1,-1},
    /*120*/{-1,-1},
    /*121*/{-1,-1},
    /*122*/{-1,-1},
    /*123*/{-1,-1},
    /*124*/{-1,-1},
    /*125*/{-1,-1},
    /*126*/{-1,-1},
    /*127*/{-1,-1},
    /*128*/{-1,-1},
    /*129*/{-1,-1},
    /*130*/{19,131,-1,-1},
    /*131*/{-1,-1},
    /*132*/{-1,-1},
    /*133*/{-1,-1},
    /*134*/{-1,-1},
    /*135*/{-1,-1},
    /*136*/{-1,-1},
    /*137*/{-1,-1},
    /*138*/{-1,-1},
    /*139*/{-1,-1},
    /*140*/{-1,-1},
    /*141*/{-1,-1},
    /*142*/{-1,-1},
    /*143*/{-1,-1},
    /*144*/{-1,-1},
    /*145*/{-1,-1},
    /*146*/{-1,-1},
    /*147*/{-1,-1},
    /*148*/{-1,-1},
    /*149*/{-1,-1},
    /*150*/{-1,-1},
    /*151*/{-1,-1},
    /*152*/{7,157,16,90,17,158,-1,-1},
    /*153*/{-1,-1},
    /*154*/{-1,-1},
    /*155*/{-1,-1},
    /*156*/{-1,-1},
    /*157*/{7,159,16,90,17,160,-1,-1},
    /*158*/{-1,-1},
    /*159*/{7,161,16,90,17,162,-1,-1},
    /*160*/{-1,-1},
    /*161*/{7,163,16,90,17,164,-1,-1},
    /*162*/{-1,-1},
    /*163*/{-1,-1},
    /*164*/{-1,-1},
    /*165*/{-1,-1},
    /*166*/{-1,-1},
  };

  /** access to reduce_goto table */
  public short[][] reduce_table() {return _reduce_table;}

  /** instance of action encapsulation class */
  protected CUP$EXparser$actions action_obj;

  /** action encapsulation object initializer */
  protected void init_actions()
    {
      action_obj = new CUP$EXparser$actions();
    }

  /** invoke a user supplied parse action */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$EXparser$do_action(act_num, parser, stack, top);
  }

  /** start state */
  public int start_state() {return 0;}
  /** start production */
  public int start_production() {return 1;}

  /** EOF Symbol index */
  public int EOF_sym() {return 0;}

  /** error Symbol index */
  public int error_sym() {return 1;}


  /** user initialization */
  public void user_init() throws java.lang.Exception
    {
 action_obj.setUseMultiplier( UseMultiplier ); 
    }

  /** scan to get the next Symbol */
  public java_cup.runtime.Symbol scan()
    throws java.lang.Exception
    {
 return( scanSymbol() ); 
    }

 


protected boolean UseMultiplier = false;


/**
* Parses the list of symbols input, given the number of unmatched parens.
*/
protected ELexeme parseAll( HighLevelList PromptList , boolean UseMult )
	{
	UseMultiplier = UseMult;
	Symbol MySym = null;
	ELexeme MyLex = null;
	MyList = PromptList;
	Done = false;

	if( !( MyList.empty() ) )
		MyList.searchHead();
		else Done = true;

	try
		{
		MySym = parse();
		MyLex = (ELexeme)( MySym.value );
		}
		catch( Exception e ) { /* e.printStackTrace(); */ }

	return( MyLex );
	};


/**
* Scans the next symbol.
*/
protected Symbol scanSymbol( )
	{
	int tag = EXsym.EOF;
	Object val = null;

	if( !Done )
		{
		val = MyList.getNode();

		if( val instanceof ELexeme )
			{
			ELexeme eval = (ELexeme) val;
			tag = eval.getTopOp();
			eval.setParenCount( 0 );

			if( tag == EXsym.variable )
				{
				DrawObj MyDraw = ( (ELexeme) val ).getTopDrawObj();
				FlexString MyStr = new FlexString();
				MyDraw.getVectName().copyString( MyStr );
				eval.setTopPrompt( MyStr );
				}
			}
			else
			{
			tag = EXsym.digit;
			val = ( (ObjObj) val ).value;
			}

		MyList.right();
		Done = MyList.getHead();
		}

	Symbol MySym = new Symbol( tag , val );
	return( MySym );
	}


/**
* List of symbols to scan.
*/
protected HighLevelList MyList = null;

/**
* Indicates whether the entire list has been scanned.
*/
protected boolean Done = false;


}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$EXparser$actions {





	//$$strtCprt
	/**
	* Vector Victor -- Graphing Calculator Program For Android
	* 
	* Copyright (C) 1993-2013 Thornton Green
	* 
	* This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as
	* published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.
	* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty 
	* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
	* You should have received a copy of the GNU General Public License along with this program; if not, 
	* see <http://www.gnu.org/licenses>.
	* Additional permission under GNU GPL version 3 section 7
	*
	* If you modify this Program, or any covered work, by linking or combining it with Android 
	* (or a modified version of that library), containing parts covered by the terms of the Android licenses, 
	* the licensors of this Program grant you additional permission to convey the resulting work. {Corresponding Source for
	* a non-source form of such a combination shall include the source code for the parts of Android used as well 
	* as that of the covered work.}
	* 
	* If you modify this Program, or any covered work, by linking or combining it with Dexmaker 
	* (or a modified version of that library), containing parts covered by the terms of Apache License 2.0, 
	* the licensors of this Program grant you additional permission to convey the resulting work. {Corresponding Source for
	* a non-source form of such a combination shall include the source code for the parts of Dexmaker used as well 
	* as that of the covered work.}
	* 
	* If you modify this Program, or any covered work, by linking or combining it with JLex 
	* (or a modified version of that library), containing parts covered by the terms of JLex license listed below, 
	* the licensors of this Program grant you additional permission to convey the resulting work. {Corresponding Source for
	* a non-source form of such a combination shall include the source code for the parts of JLex used as well 
	* as that of the covered work.}
	* 
	* If you modify this Program, or any covered work, by linking or combining it with Java CUP 
	* (or a modified version of that library), containing parts covered by the terms of Java CUP license listed below, 
	* the licensors of this Program grant you additional permission to convey the resulting work. {Corresponding Source for
	* a non-source form of such a combination shall include the source code for the parts of Java CUP used as well 
	* as that of the covered work.}
	* 
	* If you modify this Program, or any covered work, by linking or combining it with TwoDScrollView 
	* (or a modified version of that library), containing parts covered by the terms of Apache License 2.0, 
	* the licensors of this Program grant you additional permission to convey the resulting work. {Corresponding Source for
	* a non-source form of such a combination shall include the source code for the parts of TwoDScrollView used as well 
	* as that of the covered work.}
	*
	*
	* Android is available at http://android.com
	*
	* Dexmaker is available at https://code.google.com/p/dexmaker/
	*
	* JLex is available at http://freecode.com/projects/jlex
	* 
	* Java CUP is available at http://www2.cs.turn.edu/projects/cup/
	* 
	* TwoDScrollView is available at http://blog.gorges.us/2010/06/android-two-dimensional-scrollview/
	*
	*
	* The licenses for Java CUP and JLex are listed below:
	* 
	* ****************************************************************************
	*
	* JLex COPYRIGHT NOTICE, LICENSE AND DISCLAIMER. 
	*
	* Copyright 1996 by Elliot Joel Berk. 
	*
	* Permission to use, copy, modify, and distribute this software and its documentation for any 
	* purpose and without fee is hereby granted, provided that the above copyright notice appear 
	* in all copies and that both the copyright notice and this permission notice and warranty 
	* disclaimer appear in supporting documentation, and that the name of Elliot Joel Berk not be 
	* used in advertising or publicity pertaining to distribution of the software without specific, 
	* written prior permission. 
	*
	* Elliot Joel Berk disclaims all warranties with regard to this software, including all implied 
	* warranties of merchantability and fitness. In no event shall Elliot Joel Berk be liable for 
	* any special, indirect or consequential damages or any damages whatsoever resulting from loss 
	* of use, data or profits, whether in an action of contract, negligence or other tortious 
	* action, arising out of or in connection with the use or performance of this software. 
	* 
	* ********************************************************************************
	*
	* CUP Parser Generator Copyright Notice, License, and Disclaimer
	* 
	* Copyright 1996-1999 by Scott Hudson, Frank Flannery, C. Scott Ananian 
	* 
	* Permission to use, copy, modify, and distribute this software and its documentation for any 
	* purpose and without fee is hereby granted, provided that the above copyright notice appear 
	* in all copies and that both the copyright notice and this permission notice and warranty 
	* disclaimer appear in supporting documentation, and that the names of the authors or their 
	* employers not be used in advertising or publicity pertaining to distribution of the software 
	* without specific, written prior permission. 
	* 
	* The authors and their employers disclaim all warranties with regard to this software, 
	* including all implied warranties of merchantability and fitness. In no event shall the 
	* authors or their employers be liable for any special, indirect or consequential damages or 
	* any damages whatsoever resulting from loss of use, data or profits, whether in an action of 
	* contract, negligence or other tortious action, arising out of or in connection with the use 
	* or performance of this software.
	*
	* ******************************************************************************
	*
	*
	*/
	//$$endCprt




/**
*
* --- SOURCE MODIFICATION LIST ---
*
* Please document all changes to this source file here.
* Feel free to add rows if needed.
*
*
*    |-----------------------|-------------------------------------------------|----------------------------------------------------------------------|---------------------------------------------------------------...
*    | Date of Modification  |    Author of Modification                       |    Reason for Modification                                           |    Description of Modification (use multiple rows if needed)  ... 
*    |-----------------------|-------------------------------------------------|----------------------------------------------------------------------|---------------------------------------------------------------...
*    |                       |                                                 |                                                                      |
*    | 9/24/2000             | Thorn Green (viridian_1138@yahoo.com)           | Needed to provide a standard way to document source file changes.    | Added a souce modification list to the documentation so that changes to the souce could be recorded. 
*    | 10/22/2000            | Thorn Green (viridian_1138@yahoo.com)           | Methods did not have names that followed standard Java conventions.  | Performed a global modification to bring the names within spec.
*    | 10/29/2000            | Thorn Green (viridian_1138@yahoo.com)           | Classes did not have names that followed standard Java conventions.  | Performed a global modification to bring the names within spec.
*    | 01/26/2001            | Thorn Green (viridian_1138@yahoo.com)           | Previous name re-map caused DomVect to be spelled DoMvect            | Fixed the error in spelling.
*    | 10/02/2002            | Thorn Green (viridian_1138@yahoo.com)           | Improve comparison operation (GeoCard).                              | Made several changes to comparison operator.
*    | 10/14/2002            | Thorn Green (viridian_1138@yahoo.com)           | Dlike proportion operator (GeoCard).                                 | Introduced Dlike proportion.
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*
*
*/



protected boolean UseMultiplier = false;
protected boolean BladeAddOnly = true;


/**
* Sets whether to use multiplication signs.
*/
	public final void setUseMultiplier( boolean in )
		{ UseMultiplier = in; }


/**
* Gets whether to use multiplication signs.
*/
	private final boolean getUseMultiplier( )
		{ return( UseMultiplier ); }


/**
* Inserts a the prefix of a binary operation to a string.
*/
	private void keyInsertBinaryPrefixOpString( int KeyOp , FlexString in )
		{
		switch( KeyOp )
			{
			case EXsym.TraceGraph:
				in.insertJavaString( "TraceGraph( " );
				break;

			case EXsym.power:
				in.insertJavaString( "<BOX>" );
				break;
			}
		}


/**
* Inserts a the suffix of a binary operation to a string.
*/
	private void keyInsertBinarySuffixOpString( int KeyOp , FlexString in )
		{
		switch( KeyOp )
			{
			case EXsym.TraceGraph:
				in.insertJavaString( " )" );
				break;

			case EXsym.power:
				in.insertJavaString( "</SUP>" );
				break;
			}
		}


/**
* Inserts a binary operator to a string.
*/
	private void keyInsertBinaryOpString( int KeyOp , int e1 , int e2 , FlexString in )
		{
		switch( KeyOp )
			{
			case EXsym.prod:
				if( getUseMultiplier() )
					{
					in.insertJavaString( " &times; " );
					}
					else
					{
					if( ( e2 == ELexeme.Boxed ) || ( e1 == ELexeme.Boxed ) )
						{ in.insertJavaString( " &times; " ); }
						else { in.insertJavaString( "&itimes;" ); }
					}
				break;

			case EXsym.div:
				in.insertJavaString( " / " );
				break;

			case EXsym.plus:
				in.insertJavaString( " + " );
				break;

			case EXsym.minus:
				in.insertJavaString( " - " );
				break;

			case EXsym.compare:
				in.insertJavaString( " Compare " );
				break;

			case EXsym.assign:
				in.insertJavaString( " := " );
				break;

			case EXsym.TraceGraph:
				in.insertJavaString( " , " );
				break;

			case EXsym.power:
				in.insertJavaString( "</BOX><SUP>" );
				break;

			case EXsym.dot:
				in.insertJavaString( " &cdot; " );
				break;

			case EXsym.cross:
				in.insertJavaString( " <BT>&times;</BT> " );
				break;

			case EXsym.wedge:
				in.insertJavaString( " <BT>^</BT> " );
				break;

			case EXsym.dlikeProp:
				in.insertJavaString( " / " );
				break;
			}
		}


/**
* Inserts the prefix markup for a unary op.
*/
	private void keyInsertUnaryPrefixOpString( int KeyOp , FlexString in )
		{
		switch( KeyOp )
			{
			case EXsym.uplus:
				in.insertJavaString( "+" );
				break;

			case EXsym.negation:
				in.insertJavaString( "-" );
				break;

			case EXsym.magnitude:
				in.insertJavaString( "| " );
				break;

			case EXsym.square:
				in.insertJavaString( "<BOX>" );
				break;

			case EXsym.inverse:
				in.insertJavaString( "<BOX>" );
				break;

			case EXsym.sqrt:
				in.insertJavaString( "<BOX>" );
				break;

			case EXsym.exp:
				in.insertJavaString( "<BOX>e</BOX><SUP>" );
				break;

			case EXsym.ScalGradPart:
			case EXsym.ImagGradPart:
				in.insertJavaString( "<BOX>&lt; " );
				break;

			}
		}


/**
* Inserts the suffix markup for a unary op.
*/
	private void keyInsertUnarySuffixOpString( int KeyOp , FlexString in )
		{
		switch( KeyOp )
			{

			case EXsym.magnitude:
				in.insertJavaString( " |" );
				break;

			case EXsym.square:
				in.insertJavaString( "</BOX><SUP>2</SUP>" );
				break;

			case EXsym.inverse:
				in.insertJavaString( "</BOX><SUP>-1</SUP>" );
				break;

			case EXsym.sqrt:
				in.insertJavaString( "</BOX><SUP>1/2</SUP>" );
				break;

			case EXsym.exp:
				in.insertJavaString( "</SUP>" );
				break;

			case EXsym.ScalGradPart:
				in.insertJavaString( " &gt;</BOX><SUB>0</SUB>" );
				break;

			case EXsym.ImagGradPart:
				in.insertJavaString( " &gt;</BOX><SUB>2</SUB>" );
				break;

			}
		}

/**
* Returns a lexeme for a box.
*/
protected ELexeme returnBox( )
	{
	ELexeme BoxLex = new ELexeme();
	BoxLex.setTopPrompt( new FlexString( "&sbox;" ) );
	BoxLex.setFillStat( ELexeme.Boxed );
	return( BoxLex );
	}

/**
* Returns a lexeme for an empty line.
*/
protected ELexeme returnEmptyLine( )
	{
	ELexeme BoxLex = new ELexeme();
	BoxLex.setTopPrompt( new FlexString( "" ) );
	BoxLex.setFillStat( ELexeme.Boxed );
	return( BoxLex );
	}

/**
* Domain value for erroneous operations.
*/
protected final int dom_err = 2 * DepictorPort.DOM_PSU;


/**
* Gets the domain resulting from a division operation on the two input domains.
*/
protected int getDlikePropDomain( int i1 , int i2 )
	{ return( getDivisionDomain( i1 , i2 ) ); }


/**
* Gets the domain resulting from a division operation on the two input domains.
*/
protected int getDivisionDomain( int i1 , int i2 )
	{
	int domain = dom_err;

	if( i1 == DepictorPort.DOM_SCA )
		{
		if( i2 != dom_err )
			domain = i2;
		}

	if( i1 == ( DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2 ) )
		{
		if( i2 == DepictorPort.DOM_SCA )
			domain = i1;

		if( i2 == ( DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2 ) )
			domain = DepictorPort.DOM_SCA + DepictorPort.DOM_PSU;

		if( i2 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) )
			domain = DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2;

		if( i2 == DepictorPort.DOM_PSU )
			domain = DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2;
		}

	if( i1 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) )
		{
		if( i2 == DepictorPort.DOM_SCA )
			domain = i1;

		if( i2 == ( DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2 ) )
			domain = DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2;

		if( i2 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) )
			domain = DepictorPort.DOM_SCA + DepictorPort.DOM_PSU;

		if( i2 == DepictorPort.DOM_PSU )
			domain = DepictorPort.DOM_SCA + DepictorPort.DOM_PSU;
		}

	if( i1 == DepictorPort.DOM_PSU )
		{
		if( i2 == DepictorPort.DOM_SCA )
			domain = i1;

		if( i2 == ( DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2 ) )
			domain = DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2;

		if( i2 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) )
			domain = DepictorPort.DOM_SCA + DepictorPort.DOM_PSU;

		if( i2 == DepictorPort.DOM_PSU )
			domain = DepictorPort.DOM_SCA;
		}

	return( domain );
	}

/**
* Returns the domain produced by a multiplication operation on the two input domains.
*/
protected int getProductDomain( int i1 , FlexString prompt1 , int i2 , FlexString prompt2 )
	{
	int domain = dom_err;

	if( i1 == DepictorPort.DOM_SCA )
		{
		if( i2 != dom_err )
			domain = i2;
		}

	if( i1 == ( DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2 ) )
		{
		if( i2 == DepictorPort.DOM_SCA )
			domain = i1;

		if( i2 == ( DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2 ) )
			{
			if( prompt1.stcmp( prompt2 ) == 0 )
				domain = DepictorPort.DOM_SCA;
				else domain = DepictorPort.DOM_SCA + DepictorPort.DOM_PSU;
			}

		if( i2 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) )
			domain = DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2;

		if( i2 == DepictorPort.DOM_PSU )
			domain = DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2;
		}

	if( i1 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) )
		{
		if( i2 == DepictorPort.DOM_SCA )
			domain = i1;

		if( i2 == ( DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2 ) )
			domain = DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2;

		if( i2 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) )
			domain = DepictorPort.DOM_SCA + DepictorPort.DOM_PSU;

		if( i2 == DepictorPort.DOM_PSU )
			domain = DepictorPort.DOM_SCA + DepictorPort.DOM_PSU;
		}

	if( i1 == DepictorPort.DOM_PSU )
		{
		if( i2 == DepictorPort.DOM_SCA )
			domain = i1;

		if( i2 == ( DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2 ) )
			domain = DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2;

		if( i2 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) )
			domain = DepictorPort.DOM_SCA + DepictorPort.DOM_PSU;

		if( i2 == DepictorPort.DOM_PSU )
			domain = DepictorPort.DOM_SCA;
		}

	return( domain );
	}

/**
* Gets the domain produced by an addition operation on the two input domains.
*/
protected int getAddDomain( int i1 , int i2 )
	{
	int domain = dom_err;

	if( BladeAddOnly )
		{
		if( i1 == DepictorPort.DOM_SCA )
			{
			if( i2 == DepictorPort.DOM_SCA )
				domain = i1 | i2;

			if( i2 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) )
				domain = i1 | i2;

			if( i2 == DepictorPort.DOM_PSU )
				domain = i1 | i2;
			}

		if( i1 == ( DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2 ) )
			{
			if( i2 == ( DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2 ) )
				domain = i1 | i2;
			}

		if( i1 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) )
			{
			if( i2 == DepictorPort.DOM_SCA )
				domain = i1 | i2;

			if( i2 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) )
				domain = i1 | i2;

			if( i2 == DepictorPort.DOM_PSU )
				domain = i1 | i2;
			}

		if( i1 == DepictorPort.DOM_PSU )
			{
			if( i2 == DepictorPort.DOM_SCA )
				domain = i1 | i2;

			if( i2 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) )
				domain = i1 | i2;

			if( i2 == DepictorPort.DOM_PSU )
				domain = i1 | i2;
			}
		}
		else
		{
		if( ( i1 != dom_err ) && ( i2 != dom_err ) )
			domain = i1 | i2;
		}

	return( domain );
	}


/**
* Gets the domain produced by a dot product operation on the two input domains.
*/
protected int getDotDomain( int i1 , int i2 )
	{
	int domain = dom_err;

	if( i1 == ( DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2 ) )
		{
		if( i2 == ( DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2 ) )
			{
			domain = DepictorPort.DOM_SCA;
			}

		if( i2 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) )
			domain = DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2;

		if( i2 == DepictorPort.DOM_PSU )
			domain = DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2;
		}

	if( i1 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) )
		{
		if( i2 == ( DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2 ) )
			domain = DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2;

		if( i2 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) )
			domain = DepictorPort.DOM_SCA;

		if( i2 == DepictorPort.DOM_PSU )
			domain = DepictorPort.DOM_SCA;
		}

	if( i1 == DepictorPort.DOM_PSU )
		{
		if( i2 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) )
			domain = DepictorPort.DOM_SCA;

		if( i2 == ( DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2 ) )
			domain = DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2;

		if( i2 == DepictorPort.DOM_PSU )
			domain = DepictorPort.DOM_SCA;
		}

	return( domain );
	}


/**
* Gets the domain produced by a cross product operation on the two input domains.
*/
protected int getCrossDomain( int i1 , int i2 )
	{
	int domain = dom_err;

	if( i1 == DepictorPort.DOM_SCA )
		{
		if( i2 == DepictorPort.DOM_SCA )
			domain = DepictorPort.DOM_PSU;

		if( i2 == ( DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2 ) )
			{
			domain = i1;
			}

		if( i2 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) )
			domain = i1;

		if( i2 == DepictorPort.DOM_PSU )
			domain = DepictorPort.DOM_SCA;
		}

	if( i1 == ( DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2 ) )
		{
		if( i2 == DepictorPort.DOM_SCA )
			domain = i1;

		if( i2 == ( DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2 ) )
			{
			domain = DepictorPort.DOM_SCA;
			}

		if( i2 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) )
			domain = DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2;

		}

	if( i1 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) )
		{
		if( i2 == DepictorPort.DOM_SCA )
			domain = i1;

		if( i2 == ( DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2 ) )
			domain = DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2;

		if( i2 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) )
			domain = DepictorPort.DOM_SCA + DepictorPort.DOM_PSU;

		if( i2 == DepictorPort.DOM_PSU )
			domain = DepictorPort.DOM_SCA + DepictorPort.DOM_PSU;
		}

	if( i1 == DepictorPort.DOM_PSU )
		{
		if( i2 == DepictorPort.DOM_SCA )
			domain = DepictorPort.DOM_SCA;

		if( i2 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) )
			domain = DepictorPort.DOM_SCA + DepictorPort.DOM_PSU;

		}

	return( domain );
	}


/**
* Gets the domain produced by a wedge product operation on the two input domains.
*/
protected int getWedgeDomain( int i1 , int i2 )
	{
	int domain = dom_err;

	if( i1 == DepictorPort.DOM_SCA )
		{
		if( i2 != dom_err )
			domain = i2;
		}

	if( i1 == ( DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2 ) )
		{
		if( i2 == DepictorPort.DOM_SCA )
			domain = i1;

		if( i2 == ( DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2 ) )
			{
			domain = DepictorPort.DOM_PSU;
			}

		if( i2 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) )
			domain = DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2;

		}

	if( i1 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) )
		{
		if( i2 == DepictorPort.DOM_SCA )
			domain = i1;

		if( i2 == ( DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2 ) )
			domain = DepictorPort.DOM_VECT1 + DepictorPort.DOM_VECT2;

		if( i2 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) )
			domain = DepictorPort.DOM_SCA + DepictorPort.DOM_PSU;

		if( i2 == DepictorPort.DOM_PSU )
			domain = DepictorPort.DOM_SCA + DepictorPort.DOM_PSU;
		}

	if( i1 == DepictorPort.DOM_PSU )
		{
		if( i2 == DepictorPort.DOM_SCA )
			domain = i1;

		if( i2 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) )
			domain = DepictorPort.DOM_SCA + DepictorPort.DOM_PSU;

		}

	return( domain );
	}


/**
* Gets the expression for the first parameter of the lexeme.
*/
protected void insertParamOneExpr( ELexeme in , FlexString expr )
	{
	if( ( in.getFillStat() & ELexeme.FilledParamOne ) != 0 )
		{
		FlexString ParamOneExpr = in.getParamOneExpr();
		ParamOneExpr.insertString( expr );
		}
		else
		{
		DrawObj ParamOneObj = in.getParamOneDrawObj();
		expr.insertChar( '\'' );
		ParamOneObj.getVectName().insertString( expr );
		expr.insertChar( '\'' );
		}
	}


/**
* Gets the expression for the second parameter of the lexeme.
*/
protected void insertParamTwoExpr( ELexeme in , FlexString expr )
	{
	if( ( in.getFillStat() & ELexeme.FilledParamTwo ) != 0 )
		{
		FlexString ParamTwoExpr = in.getParamTwoExpr();
		ParamTwoExpr.insertString( expr );
		}
		else
		{
		DrawObj ParamTwoObj = in.getParamTwoDrawObj();
		expr.insertChar( '\'' );
		ParamTwoObj.getVectName().insertString( expr );
		expr.insertChar( '\'' );
		}
	}


/**
* Gets the expression for the third parameter of the lexeme.
*/
protected void insertTopExpr( ELexeme in , FlexString expr )
	{
	if( in.getTopOp() == EXsym.variable )
		{
		DrawObj TopObj = in.getTopDrawObj();
		expr.insertChar( '\'' );
		TopObj.getVectName().insertString( expr );
		expr.insertChar( '\'' );
		}
		else
		{
		FlexString TopExpr = in.getTopExpr();
		TopExpr.insertString( expr );
		}
	}


/**
* Places the fill expression string for the lexeme in the private return values.
*/
private void getTopFill( ELexeme in )
	{
	int Op = in.getTopOp();
	FlexString prompt = in.getTopPrompt();
	FlexString expr = new FlexString();
	int count;


	for( count = 0 ; count < in.getParenCount() ; count++ )
		expr.insertJavaString( "( " );


	switch( Op )
		{
		case EXsym.prod:
			insertParamOneExpr( in , expr );
			expr.insertJavaString( " * " );
			insertParamTwoExpr( in , expr );
			break;

		case EXsym.plus:
			insertParamOneExpr( in , expr );
			expr.insertJavaString( " + " );
			insertParamTwoExpr( in , expr );
			break;

		case EXsym.variable:
			insertTopExpr( in , expr );
			break;

		case EXsym.minus:
			insertParamOneExpr( in , expr );
			expr.insertJavaString( " - " );
			insertParamTwoExpr( in , expr );
			break;

		case EXsym.div:
			insertParamOneExpr( in , expr );
			expr.insertJavaString( " / " );
			insertParamTwoExpr( in , expr );
			break;

		case EXsym.negation:
			expr.insertJavaString( " - " );
			insertParamOneExpr( in , expr );
			break;

		case EXsym.digit:
			insertTopExpr( in , expr );
			break;

		case EXsym.uplus:
			expr.insertJavaString( " - " );
			insertParamOneExpr( in , expr );
			break;

		case EXsym.exp:
			expr.insertJavaString( "exp( " );
			insertParamOneExpr( in , expr );
			expr.insertJavaString( " )" );
			break;

		case EXsym.sqrt:
			expr.insertJavaString( "sqrt( " );
			insertParamOneExpr( in , expr );
			expr.insertJavaString( " )" );
			break;

		case EXsym.ImagGradPart:
			expr.insertJavaString( "< " );
			insertParamOneExpr( in , expr );
			expr.insertJavaString( " >{ 2 }" );
			break;

		case EXsym.ScalGradPart:
			expr.insertJavaString( "< " );
			insertParamOneExpr( in , expr );
			expr.insertJavaString( " >{ 0 }" );
			break;

		case EXsym.power:
			expr.insertJavaString( "powr( " );
			insertParamOneExpr( in , expr );
			expr.insertJavaString( " , " );
			insertParamTwoExpr( in , expr );
			expr.insertJavaString( " )" );
			break;

		case EXsym.inverse:
			expr.insertJavaString( "inverse( " );
			insertParamOneExpr( in , expr );
			expr.insertJavaString( " )" );
			break;

		case EXsym.square:
			expr.insertJavaString( "( " );
			insertParamOneExpr( in , expr );
			expr.insertJavaString( " * " );
			insertParamOneExpr( in , expr );
			expr.insertJavaString( " )" );
			break;

		case EXsym.magnitude:
			expr.insertJavaString( "magnitude( " );
			insertParamOneExpr( in , expr );
			expr.insertJavaString( " )" );
			break;

		case EXsym.dot:
			insertParamOneExpr( in , expr );
			expr.insertJavaString( " dot " );
			insertParamTwoExpr( in , expr );
			break;

		case EXsym.cross:
			insertParamOneExpr( in , expr );
			expr.insertJavaString( " cross " );
			insertParamTwoExpr( in , expr );
			break;

		case EXsym.wedge:
			insertParamOneExpr( in , expr );
			expr.insertJavaString( " wedge " );
			insertParamTwoExpr( in , expr );
			break;

		case EXsym.dlikeProp:
			insertParamOneExpr( in , expr );
			expr.insertJavaString( " / " );
			insertParamTwoExpr( in , expr );
			break;

		}


	for( count = 0 ; count < in.getParenCount() ; count++ )
		expr.insertJavaString( " )" );


	ReturnExpr = expr;
	ReturnPrompt = prompt;
	}


private FlexString ReturnExpr = null;
private FlexString ReturnPrompt = null;



/**
* Places the fill expression string for the lexeme in the private return values.
*/
private int getTopDomain( ELexeme in )
	{
	int Op = in.getTopOp();
	int domain = dom_err;
	int d1 = in.getParamOneDomain();
	int d2 = in.getParamTwoDomain();
	int count;


	switch( Op )
		{
		case EXsym.prod:
			domain = getProductDomain( d1 , in.getParamOnePrompt() , d2 , in.getParamTwoPrompt() );
			break;

		case EXsym.plus:
			domain = getAddDomain( d1 , d2 );
			break;

		case EXsym.variable:
			domain = d1;
			break;

		case EXsym.minus:
			domain = getAddDomain( d1 , d2 );
			break;

		case EXsym.div:
			domain = getDivisionDomain( d1 , d2 );
			break;

		case EXsym.dlikeProp:
			domain = getDlikePropDomain( d1 , d2 );
			break;

		case EXsym.negation:
			domain = d1;
			break;

		case EXsym.digit:
			domain = DepictorPort.DOM_SCA;
			break;

		case EXsym.uplus:
			domain = d1;
			break;

		case EXsym.exp:
			if( ( d1 == DepictorPort.DOM_SCA ) || ( d1 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) ) )
				domain = d1;

			if( d1 == DepictorPort.DOM_PSU )
				domain = DepictorPort.DOM_SCA + DepictorPort.DOM_PSU;
			break;

		case EXsym.sqrt:
			if( ( d1 == DepictorPort.DOM_SCA ) || ( d1 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) ) )
				domain = DepictorPort.DOM_SCA + DepictorPort.DOM_PSU;

			if( d1 == DepictorPort.DOM_PSU )
				domain = DepictorPort.DOM_SCA + DepictorPort.DOM_PSU;
			break;

		case EXsym.ImagGradPart:
			if( d1 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) )
				domain = DepictorPort.DOM_SCA + DepictorPort.DOM_PSU;
			if( d1 == DepictorPort.DOM_PSU )
				domain = DepictorPort.DOM_SCA + DepictorPort.DOM_PSU;
			break;

		case EXsym.ScalGradPart:
			if( ( d1 == DepictorPort.DOM_SCA ) || ( d1 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) ) )
				domain = DepictorPort.DOM_SCA;
			break;

		case EXsym.power:
			if( ( ( d1 == DepictorPort.DOM_SCA ) || ( d1 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) ) || ( d1 == DepictorPort.DOM_PSU ) ) &&
				( ( d2 == DepictorPort.DOM_SCA ) || ( d2 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) ) || ( d2 == DepictorPort.DOM_PSU ) ) )
				domain = DepictorPort.DOM_SCA + DepictorPort.DOM_PSU;
			break;

		case EXsym.inverse:
			domain = getDivisionDomain( DepictorPort.DOM_SCA , d1 );
			break;

		case EXsym.square:
			domain = getProductDomain( d1 , in.getParamOnePrompt() , d1 , in.getParamOnePrompt() );
			break;

		case EXsym.magnitude:
			if( d1 != dom_err )
				domain = DepictorPort.DOM_SCA;
			break;

		case EXsym.dot:
			domain = getDotDomain( d1 , d2 );
			break;

		case EXsym.cross:
			domain = getCrossDomain( d1 , d2 );
			break;

		case EXsym.wedge:
			domain = getWedgeDomain( d1 , d2 );
			break;

		case EXsym.assign:
			if( ( d1 != dom_err ) && ( d2 != dom_err ) && 
				( ( d1 | d2 ) == d1 ) ) domain = d1;
			break;

		case EXsym.compare:
			if( ( d1 != dom_err ) && ( d2 != dom_err ) )
				{
				if( d1 == d2 ) domain = d1;
				if( ( d1 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) ) && 
					( d2 == DepictorPort.DOM_PSU ) ) domain = 0;
				if( ( d1 == DepictorPort.DOM_PSU ) && 
					( d2 == ( DepictorPort.DOM_SCA + DepictorPort.DOM_PSU ) ) ) domain = 0;
				}
			break;

		case EXsym.TraceGraph:
			if( d1 == DepictorPort.DOM_SCA ) domain = d1;
			break;

		}


	return( domain );
	}


/**
* Adds a set of parens. to a lexeme.
*/
protected ELexeme parenExpr( ELexeme in )
	{
	FlexString str = in.getTopPrompt();
	str.setInsertPoint( 0 );
	str.insertJavaString( "<APPLY>( " );
	str.setInsertPoint( str.strlen() );
	str.insertJavaString( " )</APPLY>" );

	in.setParenCount( in.getParenCount() + 1 );
	return( in );
	}


/**
* Builds the lexeme for a binary expression without knowledge of the operator.
*/
protected ELexeme buildAnonymousBinary( ELexeme e1 , ELexeme e2 )
	{
	return( buildAnonymousBinary( e1 , e2 , false ) );
	}


/**
* Builds the lexeme for a binary expression without knowledge of the operator.
*/
protected ELexeme buildAnonymousBinary( ELexeme e1 , ELexeme e2 , boolean ConjunctOp )
	{
	ELexeme MyLex = new ELexeme();

	boolean b1 = ( ConjunctOp ) && ( e1.getTopOp() == EXsym.digit ) && !( getUseMultiplier() );

	boolean b2 = ( ConjunctOp ) && ( e2.getTopOp() == EXsym.digit ) && !( getUseMultiplier() );

	if( e1.getTopDrawExpr() || b1 )
		e1 = parenExpr( e1 );

	if( e2.getTopDrawExpr() || b2 )
		e2 = parenExpr( e2 );

	int stat1 = e1.getFillStat();
	int stat2 = e2.getFillStat();
	int stat = stat1 | stat2;
	if( ( stat & ELexeme.Boxed ) != 0 )
		{
		MyLex.setFillStat( ELexeme.Boxed );

		if( ( ( stat1 & ELexeme.Boxed ) != 0 ) || ( ( stat1 & ELexeme.Filled ) != 0 ) )
			{
			MyLex.setParamOneFill( e1.getTopPrompt() , null , 0 );
			}
			else
			{
			MyLex.setParamOneDraw( e1.getTopPrompt() , e1.getTopDraw() );
			}

		if( ( ( stat2 & ELexeme.Boxed ) != 0 ) || ( ( stat2 & ELexeme.Filled ) != 0 ) )
			{
			MyLex.setParamTwoFill( e2.getTopPrompt() , null , 0 );
			}
			else
			{
			MyLex.setParamTwoDraw( e2.getTopPrompt() , e2.getTopDraw() );
			}
		}
		else
		{
		MyLex.setFillStat( ELexeme.Filled );

		if( ( stat & ELexeme.Filled ) != 0 )
			{
			if( ( stat1 & ELexeme.Filled ) != 0 )
				{
				getTopFill( e1 );
				MyLex.setParamOneFill( ReturnPrompt , ReturnExpr , e1.getTopDomain() );
				MyLex.setFillStat( MyLex.getFillStat() | ELexeme.FilledParamOne );
				}
				else
				{
				MyLex.setParamOneDraw( e1.getTopPrompt() , e1.getTopDraw() );
				}

			if( ( stat2 & ELexeme.Filled ) != 0 )
				{
				getTopFill( e2 );
				MyLex.setParamTwoFill( ReturnPrompt , ReturnExpr , e2.getTopDomain() );
				MyLex.setFillStat( MyLex.getFillStat() | ELexeme.FilledParamTwo );
				}
				else
				{
				MyLex.setParamTwoDraw( e2.getTopPrompt() , e2.getTopDraw() );
				}

			}
			else
			{
			MyLex.setParamOneDraw( e1.getTopPrompt() , e1.getTopDraw() );
			MyLex.setParamTwoDraw( e2.getTopPrompt() , e2.getTopDraw() );
			}
		}

	return( MyLex );
	}


/**
* Builds the lexeme for a boxed binary expression without knowledge of the operator.
*/
protected ELexeme buildAnonymousBoxedBinary( ELexeme e1 , ELexeme e2 )
	{
	ELexeme ret = buildAnonymousBinary( e1 , e2 );
	ret.setTopDrawExpr( true );
	return( ret );
	}


/**
* Configures a binary lexeme with a particular operator.
*/
protected ELexeme configureAnonymousBinary( int Op , int e1 , int e2 , ELexeme ex )
	{
	FlexString t1 = new FlexString();
	t1.setInsertPoint( 0 );
	t1.insertJavaString( "<APPLY>" );
	keyInsertBinaryPrefixOpString( Op , t1 );
	ex.getParamOnePrompt().insertString( t1 );
	keyInsertBinaryOpString( Op , e1 , e2 , t1 );
	ex.getParamTwoPrompt().insertString( t1 );
	keyInsertBinarySuffixOpString( Op , t1 );
	t1.insertJavaString( "</APPLY>" );
	ex.setTopPrompt( t1 );
	ex.setTopOp( Op );
	ex.setTopDomain( getTopDomain( ex ) );
	return( ex );
	}


/**
* Handles a binary expression.
*/
protected ELexeme handleBinary( int Op , ELexeme e1 , ELexeme e2 )
	{
	ELexeme t1 = buildAnonymousBinary( e1 , e2 , Op == EXsym.prod );
	ELexeme t2 = configureAnonymousBinary( Op , e1.getFillStat() , e2.getFillStat() , t1 );
	return( t2 );
	}


/**
* Handles a unary expression.
*/
protected ELexeme handleUnary( int Op , ELexeme e1 )
	{
	ELexeme MyLex = new ELexeme();

	if( e1.getTopDrawExpr() )
		e1 = parenExpr( e1 );

	int stat = e1.getFillStat();
	if( ( stat & ELexeme.Boxed ) != 0 )
		{
		MyLex.setFillStat( ELexeme.Boxed );
		MyLex.setParamOneFill( e1.getTopPrompt() , null , 0 );
		}
		else
		{
		if( ( stat & ELexeme.Filled ) != 0 )
			{
			getTopFill( e1 );
			MyLex.setParamOneFill( ReturnPrompt , ReturnExpr , e1.getTopDomain() );
			MyLex.setFillStat( ELexeme.Filled + ELexeme.FilledParamOne );
			}
			else
			{
			MyLex.setParamOneDraw( e1.getTopPrompt() , e1.getTopDraw() );
			MyLex.setFillStat( ELexeme.Filled );
			}
		}
	

	FlexString t1 = new FlexString();
	t1.setInsertPoint( 0 );
	t1.insertJavaString( "<APPLY>" );
	keyInsertUnaryPrefixOpString( Op , t1 );
	MyLex.getParamOnePrompt().insertString( t1 );
	keyInsertUnarySuffixOpString( Op , t1 );
	t1.insertJavaString( "</APPLY>" );
	MyLex.setTopPrompt( t1 );
	MyLex.setTopOp( Op );
	MyLex.setTopDomain( getTopDomain( MyLex ) );
	return( MyLex );
	}


/**
* Handles an assignment, comparison, or TraceGraph operation.
*/
protected ELexeme handleAssignOrCompare( int Op , ELexeme e1 , ELexeme e2 )
	{
	ELexeme MyLex = buildAnonymousBinary( e1 , e2 , Op == EXsym.prod );
	MyLex = handleAssignOrCompare( Op , e1.getFillStat() , e2.getFillStat() , MyLex );
	return( MyLex );
	}


/**
* Handles an assignment, comparison, or TraceGraph operation on a pre-built lexeme.
*/
protected ELexeme handleAssignOrCompare( int Op , int e1 , int e2 , ELexeme MyLex )
	{
	FlexString t1 = new FlexString();
	t1.setInsertPoint( 0 );
	if( Op == EXsym.compare ) t1.insertJavaString( "<APPLY>" );
	keyInsertBinaryPrefixOpString( Op , t1 );
	MyLex.getParamOnePrompt().insertString( t1 );
	keyInsertBinaryOpString( Op , e1 , e2 , t1 );
	MyLex.getParamTwoPrompt().insertString( t1 );
	keyInsertBinarySuffixOpString( Op , t1 );
	if( Op == EXsym.compare ) t1.insertJavaString( "</APPLY>" );
	MyLex.setTopPrompt( t1 );
	MyLex.setTopOp( Op );
	MyLex.setTopDomain( getTopDomain( MyLex ) );
	return( MyLex );
	}


/**
* Returns the lexeme for a numeric value.
*/
protected ELexeme handleNumber( FlexString in )
	{
	FlexString i2 = new FlexString();
	in.copyAllInfo( i2 );
	ELexeme MyLex = new ELexeme();
	MyLex.setTopOp( EXsym.digit );
	MyLex.setFillStat( ELexeme.Filled );
	MyLex.setTopFill( in , i2 , DepictorPort.DOM_SCA );
	return( MyLex );
	}


/**
* Builds the lexeme for a set of five boxes (i.e. proportion).
*/
protected ELexeme buildPentBoxFill( ELexeme e1 , ELexeme e2 , ELexeme e3 , ELexeme e4 , ELexeme e5 )
	{
	ELexeme MyLex = new ELexeme();

	if( e1.getTopDrawExpr() )
		e1 = parenExpr( e1 );

	if( e2.getTopDrawExpr() )
		e2 = parenExpr( e2 );

	if( e3.getTopDrawExpr() )
		e3 = parenExpr( e3 );

	if( e4.getTopDrawExpr() )
		e4 = parenExpr( e4 );

	if( e5.getTopDrawExpr() )
		e5 = parenExpr( e5 );

	int stat1 = e1.getFillStat();
	int stat2 = e2.getFillStat();
	int stat3 = e3.getFillStat();
	int stat4 = e4.getFillStat();
	int stat5 = e5.getFillStat();
	int stat = stat1 | stat2 | stat3 | stat4 | stat5;
	if( ( stat & ELexeme.Boxed ) != 0 )
		{
		MyLex.setFillStat( ELexeme.Boxed );

		if( ( ( stat1 & ELexeme.Boxed ) != 0 ) || ( ( stat1 & ELexeme.Filled ) != 0 ) )
			{
			MyLex.setParamOneFill( e1.getTopPrompt() , null , 0 );
			}
			else
			{
			MyLex.setParamOneDraw( e1.getTopPrompt() , e1.getTopDraw() );
			}

		if( ( ( stat2 & ELexeme.Boxed ) != 0 ) || ( ( stat2 & ELexeme.Filled ) != 0 ) )
			{
			MyLex.setParamTwoFill( e2.getTopPrompt() , null , 0 );
			}
			else
			{
			MyLex.setParamTwoDraw( e2.getTopPrompt() , e2.getTopDraw() );
			}

		if( ( ( stat3 & ELexeme.Boxed ) != 0 ) || ( ( stat3 & ELexeme.Filled ) != 0 ) )
			{
			MyLex.setParamThreeFill( e3.getTopPrompt() , null , 0 );
			}
			else
			{
			MyLex.setParamThreeDraw( e3.getTopPrompt() , e3.getTopDraw() );
			}

		if( ( ( stat4 & ELexeme.Boxed ) != 0 ) || ( ( stat4 & ELexeme.Filled ) != 0 ) )
			{
			MyLex.setParamFourFill( e4.getTopPrompt() , null , 0 );
			}
			else
			{
			MyLex.setParamFourDraw( e4.getTopPrompt() , e4.getTopDraw() );
			}

		if( ( ( stat5 & ELexeme.Boxed ) != 0 ) || ( ( stat5 & ELexeme.Filled ) != 0 ) )
			{
			MyLex.setParamFiveFill( e5.getTopPrompt() , null , 0 );
			}
			else
			{
			MyLex.setParamFiveDraw( e5.getTopPrompt() , e5.getTopDraw() );
			}
		}
		else
		{
		MyLex.setFillStat( ELexeme.Filled );

		if( ( stat & ELexeme.Filled ) != 0 )
			{
			if( ( stat1 & ELexeme.Filled ) != 0 )
				{
				getTopFill( e1 );
				MyLex.setParamOneFill( ReturnPrompt , ReturnExpr , e1.getTopDomain() );
				MyLex.setFillStat( MyLex.getFillStat() | ELexeme.FilledParamOne );
				}
				else
				{
				MyLex.setParamOneDraw( e1.getTopPrompt() , e1.getTopDraw() );
				}

			if( ( stat2 & ELexeme.Filled ) != 0 )
				{
				getTopFill( e2 );
				MyLex.setParamTwoFill( ReturnPrompt , ReturnExpr , e2.getTopDomain() );
				MyLex.setFillStat( MyLex.getFillStat() | ELexeme.FilledParamTwo );
				}
				else
				{
				MyLex.setParamTwoDraw( e2.getTopPrompt() , e2.getTopDraw() );
				}

			if( ( stat3 & ELexeme.Filled ) != 0 )
				{
				getTopFill( e3 );
				MyLex.setParamThreeFill( ReturnPrompt , ReturnExpr , e3.getTopDomain() );
				MyLex.setFillStat( MyLex.getFillStat() | ELexeme.FilledParamThree );
				}
				else
				{
				MyLex.setParamThreeDraw( e3.getTopPrompt() , e3.getTopDraw() );
				}

			if( ( stat4 & ELexeme.Filled ) != 0 )
				{
				getTopFill( e4 );
				MyLex.setParamFourFill( ReturnPrompt , ReturnExpr , e4.getTopDomain() );
				MyLex.setFillStat( MyLex.getFillStat() | ELexeme.FilledParamFour );
				}
				else
				{
				MyLex.setParamFourDraw( e4.getTopPrompt() , e4.getTopDraw() );
				}

			if( ( stat5 & ELexeme.Filled ) != 0 )
				{
				getTopFill( e5 );
				MyLex.setParamFiveFill( ReturnPrompt , ReturnExpr , e5.getTopDomain() );
				MyLex.setFillStat( MyLex.getFillStat() | ELexeme.FilledParamFive );
				}
				else
				{
				MyLex.setParamFiveDraw( e5.getTopPrompt() , e5.getTopDraw() );
				}

			}
			else
			{
			MyLex.setParamOneDraw( e1.getTopPrompt() , e1.getTopDraw() );
			MyLex.setParamTwoDraw( e2.getTopPrompt() , e2.getTopDraw() );
			MyLex.setParamThreeDraw( e3.getTopPrompt() , e3.getTopDraw() );
			MyLex.setParamFourDraw( e4.getTopPrompt() , e4.getTopDraw() );
			MyLex.setParamFiveDraw( e5.getTopPrompt() , e5.getTopDraw() );
			}
		}


	return( MyLex );
	}


/**
* Configures a pre-built lexeme for a proportion operation.
*/
protected ELexeme configureProportion( ELexeme e1 )
	{
	FlexString t1 = new FlexString();
	t1.setInsertPoint( 0 );
	e1.getParamOnePrompt().insertString( t1 );
	t1.insertJavaString( " / " );
	e1.getParamTwoPrompt().insertString( t1 );
	t1.insertJavaString( " = " );
	e1.getParamThreePrompt().insertString( t1 );
	t1.insertJavaString( " / " );
	e1.getParamFourPrompt().insertString( t1 );
	t1.insertJavaString( " =: " );
	e1.getParamFivePrompt().insertString( t1 );
	e1.setTopPrompt( t1 );
	e1.setTopOp( EXsym.proportion );
	return( e1 );
	}




  /** Constructor */
  CUP$EXparser$actions() { }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$EXparser$do_action(
    int                        CUP$EXparser$act_num,
    java_cup.runtime.lr_parser CUP$EXparser$parser,
    java.util.Stack            CUP$EXparser$stack,
    int                        CUP$EXparser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$EXparser$result;

      /* select the action based on the action number */
      switch (CUP$EXparser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // DIGITS ::= 
            {
              FlexString RESULT = null;
		 RESULT = new FlexString(); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(19/*DIGITS*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // DIGITS ::= digit DIGITS 
            {
              FlexString RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).right;
		String e1 = (String)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		FlexString e2 = (FlexString)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 e2.setInsertPoint( 0 ); e2.insertJavaString( e1 ); RESULT = e2; 
              CUP$EXparser$result = new java_cup.runtime.Symbol(19/*DIGITS*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // NUMBER ::= period digit DIGITS 
            {
              FlexString RESULT = null;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).right;
		String e2 = (String)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).value;
		int e3left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e3right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		FlexString e3 = (FlexString)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 e3.setInsertPoint( 0 ); e3.insertChar( '.' ); e3.insertJavaString( e2 ); RESULT = e3; 
              CUP$EXparser$result = new java_cup.runtime.Symbol(18/*NUMBER*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // NUMBER ::= digit DIGITS period DIGITS 
            {
              FlexString RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-3)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-3)).right;
		String e1 = (String)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-3)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).right;
		FlexString e2 = (FlexString)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).value;
		int e4left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e4right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		FlexString e4 = (FlexString)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 e4.setInsertPoint( 0 ); e4.insertJavaString( e1 ); e2.insertString( e4 ); 
			e4.insertChar( '.' ); e2.eraseAll(); RESULT = e4; 
              CUP$EXparser$result = new java_cup.runtime.Symbol(18/*NUMBER*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-3)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // NUMBER ::= digit DIGITS 
            {
              FlexString RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).right;
		String e1 = (String)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		FlexString e2 = (FlexString)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 e2.setInsertPoint( 0 ); e2.insertJavaString( e1 ); RESULT = e2; 
              CUP$EXparser$result = new java_cup.runtime.Symbol(18/*NUMBER*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // EP_INCOMPLETE_QUICK_EXP ::= 
            {
              ELexeme RESULT = null;
		 RESULT = returnBox(); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(17/*EP_INCOMPLETE_QUICK_EXP*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // EP_INCOMPLETE_QUICK_EXP ::= INCOMPLETE_QUICK_EXP 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = e1; 
              CUP$EXparser$result = new java_cup.runtime.Symbol(17/*EP_INCOMPLETE_QUICK_EXP*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // INCOMPLETE_QUICK_EXP ::= Lparen EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = parenExpr( e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(16/*INCOMPLETE_QUICK_EXP*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // INCOMPLETE_QUICK_EXP ::= Lparen EP_INCOMPLETE_EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = parenExpr( e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(16/*INCOMPLETE_QUICK_EXP*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // INCOMPLETE_QUICK_EXP ::= Lparen EP_INCOMPLETE_EXPR Rparen 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).value;
		 RESULT = parenExpr( e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(16/*INCOMPLETE_QUICK_EXP*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // EP_INCOMPLETE_BINARY_BOX_FILL ::= 
            {
              ELexeme RESULT = null;
		 RESULT = buildAnonymousBoxedBinary( returnBox() , returnBox() ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(13/*EP_INCOMPLETE_BINARY_BOX_FILL*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // EP_INCOMPLETE_BINARY_BOX_FILL ::= INCOMPLETE_BINARY_BOX_FILL 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = e1; 
              CUP$EXparser$result = new java_cup.runtime.Symbol(13/*EP_INCOMPLETE_BINARY_BOX_FILL*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // INCOMPLETE_BINARY_BOX_FILL ::= QUICK_EXP EP_INCOMPLETE_QUICK_EXP 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = buildAnonymousBoxedBinary( e1 , e2 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(12/*INCOMPLETE_BINARY_BOX_FILL*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // INCOMPLETE_BINARY_BOX_FILL ::= INCOMPLETE_QUICK_EXP 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = buildAnonymousBoxedBinary( e1 , returnBox() ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(12/*INCOMPLETE_BINARY_BOX_FILL*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // EP_INCOMPLETE_EXPR ::= 
            {
              ELexeme RESULT = null;
		 RESULT = returnBox(); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(15/*EP_INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // EP_INCOMPLETE_EXPR ::= INCOMPLETE_EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = e1; 
              CUP$EXparser$result = new java_cup.runtime.Symbol(15/*EP_INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // INCOMPLETE_EXPR ::= magnitude EP_INCOMPLETE_EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleUnary( EXsym.magnitude , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(14/*INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // INCOMPLETE_EXPR ::= exp EP_INCOMPLETE_EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleUnary( EXsym.exp , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(14/*INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // INCOMPLETE_EXPR ::= Lparen EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = parenExpr( e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(14/*INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // INCOMPLETE_EXPR ::= Lparen EP_INCOMPLETE_EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = parenExpr( e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(14/*INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // INCOMPLETE_EXPR ::= Lparen EP_INCOMPLETE_EXPR Rparen 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).value;
		 RESULT = parenExpr( e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(14/*INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // INCOMPLETE_EXPR ::= ImagGradPart EP_INCOMPLETE_EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleUnary( EXsym.ImagGradPart , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(14/*INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // INCOMPLETE_EXPR ::= ScalGradPart EP_INCOMPLETE_EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleUnary( EXsym.ScalGradPart , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(14/*INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // INCOMPLETE_EXPR ::= sqrt EP_INCOMPLETE_EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleUnary( EXsym.sqrt , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(14/*INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // INCOMPLETE_EXPR ::= inverse EP_INCOMPLETE_EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleUnary( EXsym.inverse , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(14/*INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // INCOMPLETE_EXPR ::= square EP_INCOMPLETE_EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleUnary( EXsym.square , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(14/*INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // INCOMPLETE_EXPR ::= minus EP_INCOMPLETE_EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleUnary( EXsym.negation , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(14/*INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // INCOMPLETE_EXPR ::= plus EP_INCOMPLETE_EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleUnary( EXsym.uplus , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(14/*INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // INCOMPLETE_EXPR ::= wedge EP_INCOMPLETE_BINARY_BOX_FILL 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = configureAnonymousBinary( EXsym.wedge , ELexeme.Boxed , ELexeme.Boxed , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(14/*INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // INCOMPLETE_EXPR ::= EXPR wedge EP_INCOMPLETE_EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleBinary( EXsym.wedge , e1 , e2 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(14/*INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // INCOMPLETE_EXPR ::= cross EP_INCOMPLETE_BINARY_BOX_FILL 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = configureAnonymousBinary( EXsym.cross , ELexeme.Boxed , ELexeme.Boxed , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(14/*INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // INCOMPLETE_EXPR ::= EXPR cross EP_INCOMPLETE_EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleBinary( EXsym.cross , e1 , e2 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(14/*INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // INCOMPLETE_EXPR ::= dot EP_INCOMPLETE_BINARY_BOX_FILL 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = configureAnonymousBinary( EXsym.dot , ELexeme.Boxed , ELexeme.Boxed , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(14/*INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // INCOMPLETE_EXPR ::= EXPR dot EP_INCOMPLETE_EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleBinary( EXsym.dot , e1 , e2 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(14/*INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // INCOMPLETE_EXPR ::= power EP_INCOMPLETE_BINARY_BOX_FILL 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = configureAnonymousBinary( EXsym.power , ELexeme.Boxed , ELexeme.Boxed , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(14/*INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // INCOMPLETE_EXPR ::= EXPR power EP_INCOMPLETE_EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleBinary( EXsym.power , e1 , e2 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(14/*INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // INCOMPLETE_EXPR ::= dlikeProp EP_INCOMPLETE_BINARY_BOX_FILL 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = configureAnonymousBinary( EXsym.dlikeProp , ELexeme.Boxed , ELexeme.Boxed , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(14/*INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // INCOMPLETE_EXPR ::= EXPR dlikeProp EP_INCOMPLETE_EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleBinary( EXsym.dlikeProp , e1 , e2 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(14/*INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // INCOMPLETE_EXPR ::= div EP_INCOMPLETE_BINARY_BOX_FILL 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = configureAnonymousBinary( EXsym.div , ELexeme.Boxed , ELexeme.Boxed , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(14/*INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // INCOMPLETE_EXPR ::= EXPR div EP_INCOMPLETE_EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleBinary( EXsym.div , e1 , e2 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(14/*INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // INCOMPLETE_EXPR ::= prod EP_INCOMPLETE_BINARY_BOX_FILL 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = configureAnonymousBinary( EXsym.prod , ELexeme.Boxed , ELexeme.Boxed , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(14/*INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // INCOMPLETE_EXPR ::= EXPR prod EP_INCOMPLETE_EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleBinary( EXsym.prod , e1 , e2 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(14/*INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // INCOMPLETE_EXPR ::= boxMinus EP_INCOMPLETE_BINARY_BOX_FILL 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = configureAnonymousBinary( EXsym.minus , ELexeme.Boxed , ELexeme.Boxed , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(14/*INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // INCOMPLETE_EXPR ::= EXPR minus EP_INCOMPLETE_EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleBinary( EXsym.minus , e1 , e2 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(14/*INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // INCOMPLETE_EXPR ::= boxPlus EP_INCOMPLETE_BINARY_BOX_FILL 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = configureAnonymousBinary( EXsym.plus , ELexeme.Boxed , ELexeme.Boxed , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(14/*INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // INCOMPLETE_EXPR ::= EXPR plus EP_INCOMPLETE_EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleBinary( EXsym.plus , e1 , e2 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(14/*INCOMPLETE_EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // EP_INCOMPLETE_PENT_BOX_FILL ::= 
            {
              ELexeme RESULT = null;
		 RESULT = buildPentBoxFill( returnBox() , returnBox() , returnBox() ,
			returnBox() , returnBox() ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(11/*EP_INCOMPLETE_PENT_BOX_FILL*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // EP_INCOMPLETE_PENT_BOX_FILL ::= INCOMPLETE_PENT_BOX_FILL 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = e1; 
              CUP$EXparser$result = new java_cup.runtime.Symbol(11/*EP_INCOMPLETE_PENT_BOX_FILL*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // INCOMPLETE_PENT_BOX_FILL ::= QUICK_EXP QUICK_EXP QUICK_EXP QUICK_EXP EP_INCOMPLETE_QUICK_EXP 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-4)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-4)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-4)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-3)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-3)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-3)).value;
		int e3left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left;
		int e3right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).right;
		ELexeme e3 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).value;
		int e4left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left;
		int e4right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).right;
		ELexeme e4 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).value;
		int e5left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e5right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e5 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = buildPentBoxFill( e1 , e2 , e3 , e4 , e5 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(10/*INCOMPLETE_PENT_BOX_FILL*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-4)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // INCOMPLETE_PENT_BOX_FILL ::= QUICK_EXP QUICK_EXP QUICK_EXP EP_INCOMPLETE_QUICK_EXP 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-3)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-3)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-3)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).value;
		int e3left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left;
		int e3right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).right;
		ELexeme e3 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).value;
		int e4left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e4right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e4 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = buildPentBoxFill( e1 , e2 , e3 , e4 , returnBox() ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(10/*INCOMPLETE_PENT_BOX_FILL*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-3)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // INCOMPLETE_PENT_BOX_FILL ::= QUICK_EXP QUICK_EXP EP_INCOMPLETE_QUICK_EXP 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).value;
		int e3left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e3right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e3 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = buildPentBoxFill( e1 , e2 , e3 , returnBox() , returnBox() ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(10/*INCOMPLETE_PENT_BOX_FILL*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // INCOMPLETE_PENT_BOX_FILL ::= QUICK_EXP EP_INCOMPLETE_QUICK_EXP 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = buildPentBoxFill( e1 , e2 , returnBox() , returnBox() , returnBox() ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(10/*INCOMPLETE_PENT_BOX_FILL*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // INCOMPLETE_PENT_BOX_FILL ::= INCOMPLETE_QUICK_EXP 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = buildPentBoxFill( e1 , returnBox() , returnBox() , returnBox() , returnBox() ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(10/*INCOMPLETE_PENT_BOX_FILL*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // INCOMPLETE_PURE_RELATION ::= Lparen PURE_RELATION 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = parenExpr( e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(9/*INCOMPLETE_PURE_RELATION*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // INCOMPLETE_PURE_RELATION ::= Lparen INCOMPLETE_PURE_RELATION 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = parenExpr( e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(9/*INCOMPLETE_PURE_RELATION*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // INCOMPLETE_PURE_RELATION ::= Lparen INCOMPLETE_PURE_RELATION Rparen 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).value;
		 RESULT = parenExpr( e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(9/*INCOMPLETE_PURE_RELATION*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // INCOMPLETE_PURE_RELATION ::= proportion EP_INCOMPLETE_PENT_BOX_FILL 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = configureProportion( e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(9/*INCOMPLETE_PURE_RELATION*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // INCOMPLETE_PURE_RELATION ::= TraceGraph EP_INCOMPLETE_BINARY_BOX_FILL 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleAssignOrCompare( EXsym.TraceGraph , ELexeme.Boxed , ELexeme.Boxed , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(9/*INCOMPLETE_PURE_RELATION*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // INCOMPLETE_PURE_RELATION ::= EXPR TraceGraph EP_INCOMPLETE_EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleAssignOrCompare( EXsym.TraceGraph , e1 , e2 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(9/*INCOMPLETE_PURE_RELATION*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // INCOMPLETE_PURE_RELATION ::= compare EP_INCOMPLETE_BINARY_BOX_FILL 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleAssignOrCompare( EXsym.compare , ELexeme.Boxed , ELexeme.Boxed , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(9/*INCOMPLETE_PURE_RELATION*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // INCOMPLETE_PURE_RELATION ::= EXPR compare EP_INCOMPLETE_EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleAssignOrCompare( EXsym.compare , e1 , e2 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(9/*INCOMPLETE_PURE_RELATION*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // INCOMPLETE_PURE_RELATION ::= assign variable EP_INCOMPLETE_EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleAssignOrCompare( EXsym.assign , e1 , e2 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(9/*INCOMPLETE_PURE_RELATION*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // INCOMPLETE_PURE_RELATION ::= assign 
            {
              ELexeme RESULT = null;
		 RESULT = handleAssignOrCompare( EXsym.assign , returnBox() , returnBox() ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(9/*INCOMPLETE_PURE_RELATION*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // INCOMPLETE_PURE_RELATION ::= variable assign EP_INCOMPLETE_EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleAssignOrCompare( EXsym.assign , e1 , e2 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(9/*INCOMPLETE_PURE_RELATION*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // INCOMPLETE_RELATION ::= 
            {
              ELexeme RESULT = null;
		 RESULT = returnEmptyLine(); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(8/*INCOMPLETE_RELATION*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // INCOMPLETE_RELATION ::= INCOMPLETE_PURE_RELATION 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = e1; 
              CUP$EXparser$result = new java_cup.runtime.Symbol(8/*INCOMPLETE_RELATION*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // INCOMPLETE_RELATION ::= INCOMPLETE_EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = e1; 
              CUP$EXparser$result = new java_cup.runtime.Symbol(8/*INCOMPLETE_RELATION*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // QUICK_EXP ::= Lparen EXPR Rparen 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).value;
		 RESULT = parenExpr( e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(7/*QUICK_EXP*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // QUICK_EXP ::= digit 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		String e1 = (String)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleNumber( new FlexString( e1 ) ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(7/*QUICK_EXP*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // QUICK_EXP ::= variable 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = e1; 
              CUP$EXparser$result = new java_cup.runtime.Symbol(7/*QUICK_EXP*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // BINARY_BOX_FILL ::= QUICK_EXP QUICK_EXP 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = buildAnonymousBoxedBinary( e1 , e2 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(6/*BINARY_BOX_FILL*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // EXPR ::= variable 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = e1; 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // EXPR ::= NUMBER 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		FlexString e1 = (FlexString)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleNumber( e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // EXPR ::= EXPR magnitude 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).value;
		 RESULT = handleUnary( EXsym.magnitude , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // EXPR ::= magnitude EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleUnary( EXsym.magnitude , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // EXPR ::= EXPR exp 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).value;
		 RESULT = handleUnary( EXsym.exp , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // EXPR ::= exp EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleUnary( EXsym.exp , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // EXPR ::= Lparen EXPR Rparen 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).value;
		 RESULT = parenExpr( e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // EXPR ::= EXPR ImagGradPart 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).value;
		 RESULT = handleUnary( EXsym.ImagGradPart , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // EXPR ::= ImagGradPart EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleUnary( EXsym.ImagGradPart , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // EXPR ::= EXPR ScalGradPart 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).value;
		 RESULT = handleUnary( EXsym.ScalGradPart , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // EXPR ::= ScalGradPart EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleUnary( EXsym.ScalGradPart , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // EXPR ::= EXPR sqrt 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).value;
		 RESULT = handleUnary( EXsym.sqrt , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // EXPR ::= sqrt EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleUnary( EXsym.sqrt , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // EXPR ::= EXPR inverse 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).value;
		 RESULT = handleUnary( EXsym.inverse , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // EXPR ::= inverse EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleUnary( EXsym.inverse , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // EXPR ::= EXPR square 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).value;
		 RESULT = handleUnary( EXsym.square , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // EXPR ::= square EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleUnary( EXsym.square , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // EXPR ::= minus EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleUnary( EXsym.negation , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // EXPR ::= plus EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleUnary( EXsym.uplus , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // EXPR ::= wedge BINARY_BOX_FILL 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = configureAnonymousBinary( EXsym.wedge , 0 , 0 , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // EXPR ::= EXPR wedge EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleBinary( EXsym.wedge , e1 , e2 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // EXPR ::= cross BINARY_BOX_FILL 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = configureAnonymousBinary( EXsym.cross , 0 , 0 , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // EXPR ::= EXPR cross EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleBinary( EXsym.cross , e1 , e2 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // EXPR ::= dot BINARY_BOX_FILL 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = configureAnonymousBinary( EXsym.dot , 0 , 0 , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // EXPR ::= EXPR dot EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleBinary( EXsym.dot , e1 , e2 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // EXPR ::= power BINARY_BOX_FILL 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = configureAnonymousBinary( EXsym.power , 0 , 0 , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // EXPR ::= EXPR power EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleBinary( EXsym.power , e1 , e2 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // EXPR ::= dlikeProp BINARY_BOX_FILL 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = configureAnonymousBinary( EXsym.dlikeProp , 0 , 0 , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // EXPR ::= EXPR dlikeProp EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleBinary( EXsym.dlikeProp , e1 , e2 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // EXPR ::= div BINARY_BOX_FILL 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = configureAnonymousBinary( EXsym.div , 0 , 0 , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // EXPR ::= EXPR div EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleBinary( EXsym.div , e1 , e2 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // EXPR ::= prod BINARY_BOX_FILL 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = configureAnonymousBinary( EXsym.prod , 0 , 0 , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // EXPR ::= EXPR prod EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleBinary( EXsym.prod , e1 , e2 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // EXPR ::= boxMinus BINARY_BOX_FILL 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = configureAnonymousBinary( EXsym.minus , 0 , 0 , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // EXPR ::= EXPR minus EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleBinary( EXsym.minus , e1 , e2 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // EXPR ::= boxPlus BINARY_BOX_FILL 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = configureAnonymousBinary( EXsym.plus , 0 , 0 , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // EXPR ::= EXPR plus EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleBinary( EXsym.plus , e1 , e2 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(2/*EXPR*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // PENT_BOX_FILL ::= QUICK_EXP QUICK_EXP QUICK_EXP QUICK_EXP QUICK_EXP 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-4)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-4)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-4)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-3)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-3)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-3)).value;
		int e3left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left;
		int e3right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).right;
		ELexeme e3 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).value;
		int e4left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left;
		int e4right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).right;
		ELexeme e4 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).value;
		int e5left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e5right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e5 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = buildPentBoxFill( e1 , e2 , e3 , e4 , e5 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(5/*PENT_BOX_FILL*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-4)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // PURE_RELATION ::= Lparen PURE_RELATION Rparen 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).value;
		 RESULT = parenExpr( e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(4/*PURE_RELATION*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // PURE_RELATION ::= proportion PENT_BOX_FILL 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = configureProportion( e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(4/*PURE_RELATION*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // PURE_RELATION ::= TraceGraph BINARY_BOX_FILL 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleAssignOrCompare( EXsym.TraceGraph , 0 , 0 , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(4/*PURE_RELATION*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // PURE_RELATION ::= EXPR TraceGraph EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleAssignOrCompare( EXsym.TraceGraph , e1 , e2 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(4/*PURE_RELATION*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // PURE_RELATION ::= compare BINARY_BOX_FILL 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleAssignOrCompare( EXsym.compare , 0 , 0 , e1 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(4/*PURE_RELATION*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // PURE_RELATION ::= EXPR compare EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleAssignOrCompare( EXsym.compare , e1 , e2 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(4/*PURE_RELATION*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // PURE_RELATION ::= assign variable EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleAssignOrCompare( EXsym.assign , e1 , e2 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(4/*PURE_RELATION*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // PURE_RELATION ::= variable assign EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e2 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = handleAssignOrCompare( EXsym.assign , e1 , e2 ); 
              CUP$EXparser$result = new java_cup.runtime.Symbol(4/*PURE_RELATION*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // RELATION ::= PURE_RELATION 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = e1; 
              CUP$EXparser$result = new java_cup.runtime.Symbol(3/*RELATION*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // RELATION ::= EXPR 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = e1; 
              CUP$EXparser$result = new java_cup.runtime.Symbol(3/*RELATION*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // LINE ::= INCOMPLETE_RELATION 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = e1; 
              CUP$EXparser$result = new java_cup.runtime.Symbol(1/*LINE*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // $START ::= LINE EOF 
            {
              Object RESULT = null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).right;
		ELexeme start_val = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).value;
		RESULT = start_val;
              CUP$EXparser$result = new java_cup.runtime.Symbol(0/*$START*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          /* ACCEPT */
          CUP$EXparser$parser.done_parsing();
          return CUP$EXparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // LINE ::= RELATION 
            {
              ELexeme RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right;
		ELexeme e1 = (ELexeme)((java_cup.runtime.Symbol) CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).value;
		 RESULT = e1; 
              CUP$EXparser$result = new java_cup.runtime.Symbol(1/*LINE*/, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$EXparser$stack.elementAt(CUP$EXparser$top-0)).right, RESULT);
            }
          return CUP$EXparser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

