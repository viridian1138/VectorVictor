
//----------------------------------------------------
// The following code was generated by CUP v0.10g
// Sat Feb 19 08:05:29 MST 2005
//----------------------------------------------------

package geomdir.engine;

import java_cup.runtime.*;
import meta.*;
import geomdir.Mvec;
import geomdir.IntObj;
import geomdir.ObjObj;

public class GEparser extends java_cup.runtime.lr_parser {

  /** constructor */
  public GEparser() {super();}

  /** production table */
  protected static final short _production_table[][] = {
        {3, 1},     {0, 2},     {15, 3},     {15, 3},     {15, 3}, 
        {15, 3},     {15, 3},     {15, 3},     {15, 3},     {15, 3}, 
        {15, 3},     {15, 2},     {15, 2},     {15, 3},     {15, 3}, 
        {15, 3},     {15, 3},     {15, 3},     {15, 3},     {15, 3}, 
        {15, 3},     {15, 3},     {15, 3},     {15, 3},     {15, 3}, 
        {15, 1},     {15, 1},     {15, 1},     {15, 1},     {15, 1}, 
        {15, 1},     {15, 1},     {15, 1},     {15, 1},     {15, 1}, 
        {15, 1},     {15, 1},     {15, 1},     {15, 1},     {4, 6}, 
        {9, 9},     {8, 9},     {10, 7},     {11, 7},     {12, 9}, 
        {13, 9},     {5, 1},     {5, 3},     {6, 1},     {6, 3}, 
        {1, 1},     {1, 3},     {2, 3},     {7, 3},     {14, 3}, 
        {14, 2}  };

  /** access to production table */
  public short[][] production_table() {return _production_table;}

  /** parse action table */
  protected static final short[][] _action_table = {
    /*0*/{2,7,3,13,13,8,15,39,16,11,17,19,18,6,19,14,20,34,21,22,22,32,23,36,24,27,25,30,26,4,27,3,28,10,29,21,30,24,35,9,36,31,37,35,38,16,39,17,40,25,45,23,46,33,47,38,-1,0},
    /*1*/{0,-27,2,-27,3,-27,4,-27,5,-27,6,-27,7,-27,8,-27,9,-27,10,-27,14,-27,31,-27,33,-27,34,-27,-1,0},
    /*2*/{0,-35,2,-35,3,-35,4,-35,5,-35,6,-35,7,-35,8,-35,9,-35,10,-35,14,-35,31,-35,33,-35,34,-35,-1,0},
    /*3*/{0,-34,2,-34,3,-34,4,-34,5,-34,6,-34,7,-34,8,-34,9,-34,10,-34,14,-34,31,-34,33,-34,34,-34,-1,0},
    /*4*/{0,-33,2,-33,3,-33,4,-33,5,-33,6,-33,7,-33,8,-33,9,-33,10,-33,14,-33,31,-33,33,-33,34,-33,-1,0},
    /*5*/{2,7,3,13,13,8,15,39,16,11,17,19,18,6,19,14,20,34,21,22,22,32,23,36,24,27,25,30,26,4,27,3,28,10,29,21,30,24,35,9,36,31,37,35,38,16,39,17,40,25,45,23,46,33,47,38,-1,0},
    /*6*/{2,7,3,13,13,8,15,39,16,11,17,19,18,6,19,14,20,34,21,22,22,32,23,36,24,27,25,30,26,4,27,3,28,10,29,21,30,24,35,9,36,31,37,35,38,16,39,17,40,25,45,23,46,33,47,38,-1,0},
    /*7*/{2,7,3,13,13,8,15,39,16,11,17,19,18,6,19,14,20,34,21,22,22,32,23,36,24,27,25,30,26,4,27,3,28,10,29,21,30,24,35,9,36,31,37,35,38,16,39,17,40,25,45,23,46,33,47,38,-1,0},
    /*8*/{32,68,-1,0},
    /*9*/{0,-36,2,-36,3,-36,4,-36,5,-36,6,-36,7,-36,8,-36,9,-36,10,-36,14,-36,31,-36,33,-36,34,-36,-1,0},
    /*10*/{2,7,3,13,13,8,15,39,16,11,17,19,18,6,19,14,20,34,21,22,22,32,23,36,24,27,25,30,26,4,27,3,28,10,29,21,30,24,35,9,36,31,37,35,38,16,39,17,40,25,45,23,46,33,47,38,-1,0},
    /*11*/{0,-32,2,-32,3,-32,4,-32,5,-32,6,-32,7,-32,8,-32,9,-32,10,-32,14,-32,31,-32,33,-32,34,-32,-1,0},
    /*12*/{2,7,3,13,13,8,15,39,16,11,17,19,18,6,19,14,20,34,21,22,22,32,23,36,24,27,25,30,26,4,27,3,28,10,29,21,30,24,35,9,36,31,37,35,38,16,39,17,40,25,45,23,46,33,47,38,-1,0},
    /*13*/{2,7,3,13,13,8,15,39,16,11,17,19,18,6,19,14,20,34,21,22,22,32,23,36,24,27,25,30,26,4,27,3,28,10,29,21,30,24,35,9,36,31,37,35,38,16,39,17,40,25,45,23,46,33,47,38,-1,0},
    /*14*/{0,-1,2,47,3,45,4,44,5,46,6,48,7,42,8,43,9,49,10,50,-1,0},
    /*15*/{32,68,-1,0},
    /*16*/{32,68,-1,0},
    /*17*/{0,-31,2,-31,3,-31,4,-31,5,-31,6,-31,7,-31,8,-31,9,-31,10,-31,14,-31,31,-31,33,-31,34,-31,-1,0},
    /*18*/{2,7,3,13,13,8,15,39,16,11,17,19,18,6,19,14,20,34,21,22,22,32,23,36,24,27,25,30,26,4,27,3,28,10,29,21,30,24,35,9,36,31,37,35,38,16,39,17,40,25,45,23,46,33,47,38,-1,0},
    /*19*/{0,-28,2,-28,3,-28,4,-28,5,-28,6,-28,7,-28,8,-28,9,-28,10,-28,14,-28,31,-28,33,-28,34,-28,-1,0},
    /*20*/{0,-37,2,-37,3,-37,4,-37,5,-37,6,-37,7,-37,8,-37,9,-37,10,-37,14,-37,31,-37,33,-37,34,-37,-1,0},
    /*21*/{2,7,3,13,13,8,15,39,16,11,17,19,18,6,19,14,20,34,21,22,22,32,23,36,24,27,25,30,26,4,27,3,28,10,29,21,30,24,35,9,36,31,37,35,38,16,39,17,40,25,45,23,46,33,47,38,-1,0},
    /*22*/{0,-38,2,-38,3,-38,4,-38,5,-38,6,-38,7,-38,8,-38,9,-38,10,-38,14,-38,31,-38,33,-38,34,-38,-1,0},
    /*23*/{2,7,3,13,13,8,15,39,16,11,17,19,18,6,19,14,20,34,21,22,22,32,23,36,24,27,25,30,26,4,27,3,28,10,29,21,30,24,35,9,36,31,37,35,38,16,39,17,40,25,45,23,46,33,47,38,-1,0},
    /*24*/{32,68,-1,0},
    /*25*/{0,99,-1,0},
    /*26*/{2,7,3,13,13,8,15,39,16,11,17,19,18,6,19,14,20,34,21,22,22,32,23,36,24,27,25,30,26,4,27,3,28,10,29,21,30,24,35,9,36,31,37,35,38,16,39,17,40,25,45,23,46,33,47,38,-1,0},
    /*27*/{0,-30,2,-30,3,-30,4,-30,5,-30,6,-30,7,-30,8,-30,9,-30,10,-30,14,-30,31,-30,33,-30,34,-30,-1,0},
    /*28*/{0,-26,2,-26,3,-26,4,-26,5,-26,6,-26,7,-26,8,-26,9,-26,10,-26,14,-26,31,-26,33,-26,34,-26,-1,0},
    /*29*/{2,7,3,13,13,8,15,39,16,11,17,19,18,6,19,14,20,34,21,22,22,32,23,36,24,27,25,30,26,4,27,3,28,10,29,21,30,24,35,9,36,31,37,35,38,16,39,17,40,25,45,23,46,33,47,38,-1,0},
    /*30*/{32,68,-1,0},
    /*31*/{2,7,3,13,13,8,15,39,16,11,17,19,18,6,19,14,20,34,21,22,22,32,23,36,24,27,25,30,26,4,27,3,28,10,29,21,30,24,35,9,36,31,37,35,38,16,39,17,40,25,45,23,46,33,47,38,-1,0},
    /*32*/{0,-39,2,-39,3,-39,4,-39,5,-39,6,-39,7,-39,8,-39,9,-39,10,-39,14,-39,31,-39,33,-39,34,-39,-1,0},
    /*33*/{2,7,3,13,13,8,15,39,16,11,17,19,18,6,19,14,20,34,21,22,22,32,23,36,24,27,25,30,26,4,27,3,28,10,29,21,30,24,35,9,36,31,37,35,38,16,39,17,40,25,45,23,46,33,47,38,-1,0},
    /*34*/{32,68,-1,0},
    /*35*/{2,7,3,13,13,8,15,39,16,11,17,19,18,6,19,14,20,34,21,22,22,32,23,36,24,27,25,30,26,4,27,3,28,10,29,21,30,24,35,9,36,31,37,35,38,16,39,17,40,25,45,23,46,33,47,38,-1,0},
    /*36*/{0,-29,2,-29,3,-29,4,-29,5,-29,6,-29,7,-29,8,-29,9,-29,10,-29,14,-29,31,-29,33,-29,34,-29,-1,0},
    /*37*/{2,7,3,13,13,8,14,61,15,39,16,11,17,19,18,6,19,14,20,34,21,22,22,32,23,36,24,27,25,30,26,4,27,3,28,10,29,21,30,24,35,9,36,31,37,35,38,16,39,17,40,25,45,23,46,33,47,38,-1,0},
    /*38*/{2,7,3,13,13,8,15,39,16,11,17,19,18,6,19,14,20,34,21,22,22,32,23,36,24,27,25,30,26,4,27,3,28,10,29,21,30,24,35,9,36,31,37,35,38,16,39,17,40,25,45,23,46,33,47,38,-1,0},
    /*39*/{2,47,3,45,4,44,5,46,6,48,7,42,8,43,9,49,10,50,14,41,-1,0},
    /*40*/{0,-15,2,-15,3,-15,4,-15,5,-15,6,-15,7,-15,8,-15,9,-15,10,-15,14,-15,31,-15,33,-15,34,-15,-1,0},
    /*41*/{2,7,3,13,13,8,15,39,16,11,17,19,18,6,19,14,20,34,21,22,22,32,23,36,24,27,25,30,26,4,27,3,28,10,29,21,30,24,35,9,36,31,37,35,38,16,39,17,40,25,45,23,46,33,47,38,-1,0},
    /*42*/{2,7,3,13,13,8,15,39,16,11,17,19,18,6,19,14,20,34,21,22,22,32,23,36,24,27,25,30,26,4,27,3,28,10,29,21,30,24,35,9,36,31,37,35,38,16,39,17,40,25,45,23,46,33,47,38,-1,0},
    /*43*/{2,7,3,13,13,8,15,39,16,11,17,19,18,6,19,14,20,34,21,22,22,32,23,36,24,27,25,30,26,4,27,3,28,10,29,21,30,24,35,9,36,31,37,35,38,16,39,17,40,25,45,23,46,33,47,38,-1,0},
    /*44*/{2,7,3,13,13,8,15,39,16,11,17,19,18,6,19,14,20,34,21,22,22,32,23,36,24,27,25,30,26,4,27,3,28,10,29,21,30,24,35,9,36,31,37,35,38,16,39,17,40,25,45,23,46,33,47,38,-1,0},
    /*45*/{2,7,3,13,13,8,15,39,16,11,17,19,18,6,19,14,20,34,21,22,22,32,23,36,24,27,25,30,26,4,27,3,28,10,29,21,30,24,35,9,36,31,37,35,38,16,39,17,40,25,45,23,46,33,47,38,-1,0},
    /*46*/{2,7,3,13,13,8,15,39,16,11,17,19,18,6,19,14,20,34,21,22,22,32,23,36,24,27,25,30,26,4,27,3,28,10,29,21,30,24,35,9,36,31,37,35,38,16,39,17,40,25,45,23,46,33,47,38,-1,0},
    /*47*/{2,7,3,13,13,8,15,39,16,11,17,19,18,6,19,14,20,34,21,22,22,32,23,36,24,27,25,30,26,4,27,3,28,10,29,21,30,24,35,9,36,31,37,35,38,16,39,17,40,25,45,23,46,33,47,38,-1,0},
    /*48*/{2,7,3,13,13,8,15,39,16,11,17,19,18,6,19,14,20,34,21,22,22,32,23,36,24,27,25,30,26,4,27,3,28,10,29,21,30,24,35,9,36,31,37,35,38,16,39,17,40,25,45,23,46,33,47,38,-1,0},
    /*49*/{2,7,3,13,13,8,15,39,16,11,17,19,18,6,19,14,20,34,21,22,22,32,23,36,24,27,25,30,26,4,27,3,28,10,29,21,30,24,35,9,36,31,37,35,38,16,39,17,40,25,45,23,46,33,47,38,-1,0},
    /*50*/{0,-11,2,-11,3,-11,4,-11,5,-11,6,-11,7,-11,8,-11,9,-11,10,-11,14,-11,31,-11,33,-11,34,-11,-1,0},
    /*51*/{0,-10,2,-10,3,-10,4,-10,5,-10,6,-10,7,-10,8,-10,9,-10,10,50,14,-10,31,-10,33,-10,34,-10,-1,0},
    /*52*/{0,-7,2,-7,3,-7,4,-7,5,-7,6,-7,7,-7,8,43,9,49,10,50,14,-7,31,-7,33,-7,34,-7,-1,0},
    /*53*/{0,-3,2,-3,3,-3,4,-3,5,-3,6,48,7,42,8,43,9,49,10,50,14,-3,31,-3,33,-3,34,-3,-1,0},
    /*54*/{0,-6,2,-6,3,-6,4,-6,5,-6,6,48,7,42,8,43,9,49,10,50,14,-6,31,-6,33,-6,34,-6,-1,0},
    /*55*/{0,-4,2,-4,3,-4,4,-4,5,-4,6,48,7,42,8,43,9,49,10,50,14,-4,31,-4,33,-4,34,-4,-1,0},
    /*56*/{0,-5,2,-5,3,-5,4,-5,5,-5,6,48,7,42,8,43,9,49,10,50,14,-5,31,-5,33,-5,34,-5,-1,0},
    /*57*/{0,-9,2,-9,3,-9,4,-9,5,-9,6,-9,7,-9,8,-9,9,49,10,50,14,-9,31,-9,33,-9,34,-9,-1,0},
    /*58*/{0,-8,2,-8,3,-8,4,-8,5,-8,6,-8,7,-8,8,43,9,49,10,50,14,-8,31,-8,33,-8,34,-8,-1,0},
    /*59*/{2,47,3,45,4,44,5,46,6,48,7,42,8,43,9,49,10,50,14,-49,33,-49,34,-49,-1,0},
    /*60*/{0,-56,2,-56,3,-56,4,-56,5,-56,6,-56,7,-56,8,-56,9,-56,10,-56,14,-56,31,-56,33,-56,34,-56,-1,0},
    /*61*/{14,63,34,64,-1,0},
    /*62*/{0,-55,2,-55,3,-55,4,-55,5,-55,6,-55,7,-55,8,-55,9,-55,10,-55,14,-55,31,-55,33,-55,34,-55,-1,0},
    /*63*/{2,7,3,13,13,8,15,39,16,11,17,19,18,6,19,14,20,34,21,22,22,32,23,36,24,27,25,30,26,4,27,3,28,10,29,21,30,24,35,9,36,31,37,35,38,16,39,17,40,25,45,23,46,33,47,38,-1,0},
    /*64*/{2,47,3,45,4,44,5,46,6,48,7,42,8,43,9,49,10,50,14,-50,33,-50,34,-50,-1,0},
    /*65*/{2,47,3,45,4,44,5,46,6,48,7,42,8,43,9,49,10,50,14,67,-1,0},
    /*66*/{0,-23,2,-23,3,-23,4,-23,5,-23,6,-23,7,-23,8,-23,9,-23,10,-23,14,-23,31,-23,33,-23,34,-23,-1,0},
    /*67*/{2,7,3,13,13,8,15,39,16,11,17,19,18,6,19,14,20,34,21,22,22,32,23,36,24,27,25,30,26,4,27,3,28,10,29,21,30,24,35,9,36,31,37,35,38,16,39,17,40,25,45,23,46,33,47,38,-1,0},
    /*68*/{34,70,-1,0},
    /*69*/{32,68,-1,0},
    /*70*/{34,72,-1,0},
    /*71*/{45,73,-1,0},
    /*72*/{14,74,-1,0},
    /*73*/{0,-43,2,-43,3,-43,4,-43,5,-43,6,-43,7,-43,8,-43,9,-43,10,-43,14,-43,31,-43,33,-43,34,-43,-1,0},
    /*74*/{33,76,34,64,-1,0},
    /*75*/{34,-54,-1,0},
    /*76*/{2,47,3,45,4,44,5,46,6,48,7,42,8,43,9,49,10,50,14,78,-1,0},
    /*77*/{0,-20,2,-20,3,-20,4,-20,5,-20,6,-20,7,-20,8,-20,9,-20,10,-20,14,-20,31,-20,33,-20,34,-20,-1,0},
    /*78*/{2,47,3,45,4,44,5,46,6,48,7,42,8,43,9,49,10,50,14,80,-1,0},
    /*79*/{0,-22,2,-22,3,-22,4,-22,5,-22,6,-22,7,-22,8,-22,9,-22,10,-22,14,-22,31,-22,33,-22,34,-22,-1,0},
    /*80*/{34,82,-1,0},
    /*81*/{32,68,-1,0},
    /*82*/{34,84,-1,0},
    /*83*/{32,85,-1,0},
    /*84*/{48,90,-1,0},
    /*85*/{34,87,-1,0},
    /*86*/{45,88,-1,0},
    /*87*/{14,89,-1,0},
    /*88*/{0,-41,2,-41,3,-41,4,-41,5,-41,6,-41,7,-41,8,-41,9,-41,10,-41,14,-41,31,-41,33,-41,34,-41,-1,0},
    /*89*/{33,-51,34,-51,-1,0},
    /*90*/{33,92,34,93,-1,0},
    /*91*/{34,-53,-1,0},
    /*92*/{48,94,-1,0},
    /*93*/{33,-52,34,-52,-1,0},
    /*94*/{2,47,3,45,4,44,5,46,6,48,7,42,8,43,9,49,10,50,14,96,-1,0},
    /*95*/{0,-25,2,-25,3,-25,4,-25,5,-25,6,-25,7,-25,8,-25,9,-25,10,-25,14,-25,31,-25,33,-25,34,-25,-1,0},
    /*96*/{2,47,3,45,4,44,5,46,6,48,7,42,8,43,9,49,10,50,14,98,-1,0},
    /*97*/{0,-24,2,-24,3,-24,4,-24,5,-24,6,-24,7,-24,8,-24,9,-24,10,-24,14,-24,31,-24,33,-24,34,-24,-1,0},
    /*98*/{0,-2,-1,0},
    /*99*/{34,101,-1,0},
    /*100*/{2,7,3,13,13,8,15,39,16,11,17,19,18,6,19,14,20,34,21,22,22,32,23,36,24,27,25,30,26,4,27,3,28,10,29,21,30,24,35,9,36,31,37,35,38,16,39,17,40,25,45,23,46,33,47,38,-1,0},
    /*101*/{2,47,3,45,4,44,5,46,6,48,7,42,8,43,9,49,10,50,34,103,-1,0},
    /*102*/{45,104,-1,0},
    /*103*/{34,105,-1,0},
    /*104*/{45,106,-1,0},
    /*105*/{14,107,-1,0},
    /*106*/{0,-46,2,-46,3,-46,4,-46,5,-46,6,-46,7,-46,8,-46,9,-46,10,-46,14,-46,31,-46,33,-46,34,-46,-1,0},
    /*107*/{2,47,3,45,4,44,5,46,6,48,7,42,8,43,9,49,10,50,31,109,-1,0},
    /*108*/{32,110,-1,0},
    /*109*/{45,112,-1,0},
    /*110*/{33,113,34,114,-1,0},
    /*111*/{33,-47,34,-47,-1,0},
    /*112*/{0,-40,2,-40,3,-40,4,-40,5,-40,6,-40,7,-40,8,-40,9,-40,10,-40,14,-40,31,-40,33,-40,34,-40,-1,0},
    /*113*/{45,115,-1,0},
    /*114*/{33,-48,34,-48,-1,0},
    /*115*/{2,47,3,45,4,44,5,46,6,48,7,42,8,43,9,49,10,50,14,117,-1,0},
    /*116*/{0,-21,2,-21,3,-21,4,-21,5,-21,6,-21,7,-21,8,-21,9,-21,10,-21,14,-21,31,-21,33,-21,34,-21,-1,0},
    /*117*/{2,47,3,45,4,44,5,46,6,48,7,42,8,43,9,49,10,50,14,119,-1,0},
    /*118*/{0,-17,2,-17,3,-17,4,-17,5,-17,6,-17,7,-17,8,-17,9,-17,10,-17,14,-17,31,-17,33,-17,34,-17,-1,0},
    /*119*/{34,121,-1,0},
    /*120*/{2,7,3,13,13,8,15,39,16,11,17,19,18,6,19,14,20,34,21,22,22,32,23,36,24,27,25,30,26,4,27,3,28,10,29,21,30,24,35,9,36,31,37,35,38,16,39,17,40,25,45,23,46,33,47,38,-1,0},
    /*121*/{2,47,3,45,4,44,5,46,6,48,7,42,8,43,9,49,10,50,34,123,-1,0},
    /*122*/{45,124,-1,0},
    /*123*/{34,125,-1,0},
    /*124*/{45,126,-1,0},
    /*125*/{14,127,-1,0},
    /*126*/{0,-45,2,-45,3,-45,4,-45,5,-45,6,-45,7,-45,8,-45,9,-45,10,-45,14,-45,31,-45,33,-45,34,-45,-1,0},
    /*127*/{34,129,-1,0},
    /*128*/{32,68,-1,0},
    /*129*/{34,131,-1,0},
    /*130*/{45,132,-1,0},
    /*131*/{14,133,-1,0},
    /*132*/{0,-44,2,-44,3,-44,4,-44,5,-44,6,-44,7,-44,8,-44,9,-44,10,-44,14,-44,31,-44,33,-44,34,-44,-1,0},
    /*133*/{2,47,3,45,4,44,5,46,6,48,7,42,8,43,9,49,10,50,14,135,-1,0},
    /*134*/{0,-19,2,-19,3,-19,4,-19,5,-19,6,-19,7,-19,8,-19,9,-19,10,-19,14,-19,31,-19,33,-19,34,-19,-1,0},
    /*135*/{0,-13,2,-13,3,-13,4,-13,5,-13,6,-13,7,-13,8,-13,9,-13,10,-13,14,-13,31,-13,33,-13,34,-13,-1,0},
    /*136*/{2,47,3,45,4,44,5,46,6,48,7,42,8,43,9,49,10,50,14,138,-1,0},
    /*137*/{0,-16,2,-16,3,-16,4,-16,5,-16,6,-16,7,-16,8,-16,9,-16,10,-16,14,-16,31,-16,33,-16,34,-16,-1,0},
    /*138*/{34,140,-1,0},
    /*139*/{32,68,-1,0},
    /*140*/{34,142,-1,0},
    /*141*/{32,85,-1,0},
    /*142*/{34,144,-1,0},
    /*143*/{45,145,-1,0},
    /*144*/{14,146,-1,0},
    /*145*/{0,-42,2,-42,3,-42,4,-42,5,-42,6,-42,7,-42,8,-42,9,-42,10,-42,14,-42,31,-42,33,-42,34,-42,-1,0},
    /*146*/{2,47,3,45,4,44,5,46,6,48,7,42,8,43,9,49,10,50,14,148,-1,0},
    /*147*/{0,-14,2,-14,3,-14,4,-14,5,-14,6,-14,7,-14,8,-14,9,-14,10,-14,14,-14,31,-14,33,-14,34,-14,-1,0},
    /*148*/{0,-12,2,-12,3,-12,4,-12,5,-12,6,-12,7,-12,8,-12,9,-12,10,-12,14,-12,31,-12,33,-12,34,-12,-1,0},
    /*149*/{2,47,3,45,4,44,5,46,6,48,7,42,8,43,9,49,10,50,14,151,-1,0},
    /*150*/{0,-18,2,-18,3,-18,4,-18,5,-18,6,-18,7,-18,8,-18,9,-18,10,-18,14,-18,31,-18,33,-18,34,-18,-1,0},
  };

  /** access to parse action table */
  public short[][] action_table() {return _action_table;}

  /** reduce_goto table */
  protected static final short[][] _reduce_table = {
    /*0*/{3,25,4,28,8,1,9,19,10,36,11,27,12,17,13,11,14,4,15,14,-1,-1},
    /*1*/{-1,-1},
    /*2*/{-1,-1},
    /*3*/{-1,-1},
    /*4*/{-1,-1},
    /*5*/{4,28,8,1,9,19,10,36,11,27,12,17,13,11,14,4,15,149,-1,-1},
    /*6*/{4,28,8,1,9,19,10,36,11,27,12,17,13,11,14,4,15,148,-1,-1},
    /*7*/{4,28,8,1,9,19,10,36,11,27,12,17,13,11,14,4,15,146,-1,-1},
    /*8*/{7,138,-1,-1},
    /*9*/{-1,-1},
    /*10*/{4,28,8,1,9,19,10,36,11,27,12,17,13,11,14,4,15,136,-1,-1},
    /*11*/{-1,-1},
    /*12*/{4,28,8,1,9,19,10,36,11,27,12,17,13,11,14,4,15,135,-1,-1},
    /*13*/{4,28,8,1,9,19,10,36,11,27,12,17,13,11,14,4,15,133,-1,-1},
    /*14*/{-1,-1},
    /*15*/{7,127,-1,-1},
    /*16*/{7,119,-1,-1},
    /*17*/{-1,-1},
    /*18*/{4,28,8,1,9,19,10,36,11,27,12,17,13,11,14,4,15,117,-1,-1},
    /*19*/{-1,-1},
    /*20*/{-1,-1},
    /*21*/{4,28,8,1,9,19,10,36,11,27,12,17,13,11,14,4,15,115,-1,-1},
    /*22*/{-1,-1},
    /*23*/{4,28,8,1,9,19,10,36,11,27,12,17,13,11,14,4,15,107,-1,-1},
    /*24*/{7,99,-1,-1},
    /*25*/{-1,-1},
    /*26*/{4,28,8,1,9,19,10,36,11,27,12,17,13,11,14,4,15,96,-1,-1},
    /*27*/{-1,-1},
    /*28*/{-1,-1},
    /*29*/{4,28,8,1,9,19,10,36,11,27,12,17,13,11,14,4,15,94,-1,-1},
    /*30*/{7,80,-1,-1},
    /*31*/{4,28,8,1,9,19,10,36,11,27,12,17,13,11,14,4,15,78,-1,-1},
    /*32*/{-1,-1},
    /*33*/{4,28,8,1,9,19,10,36,11,27,12,17,13,11,14,4,15,76,-1,-1},
    /*34*/{7,68,-1,-1},
    /*35*/{4,28,8,1,9,19,10,36,11,27,12,17,13,11,14,4,15,65,-1,-1},
    /*36*/{-1,-1},
    /*37*/{4,28,6,61,8,1,9,19,10,36,11,27,12,17,13,11,14,4,15,59,-1,-1},
    /*38*/{4,28,8,1,9,19,10,36,11,27,12,17,13,11,14,4,15,39,-1,-1},
    /*39*/{-1,-1},
    /*40*/{-1,-1},
    /*41*/{4,28,8,1,9,19,10,36,11,27,12,17,13,11,14,4,15,58,-1,-1},
    /*42*/{4,28,8,1,9,19,10,36,11,27,12,17,13,11,14,4,15,57,-1,-1},
    /*43*/{4,28,8,1,9,19,10,36,11,27,12,17,13,11,14,4,15,56,-1,-1},
    /*44*/{4,28,8,1,9,19,10,36,11,27,12,17,13,11,14,4,15,55,-1,-1},
    /*45*/{4,28,8,1,9,19,10,36,11,27,12,17,13,11,14,4,15,54,-1,-1},
    /*46*/{4,28,8,1,9,19,10,36,11,27,12,17,13,11,14,4,15,53,-1,-1},
    /*47*/{4,28,8,1,9,19,10,36,11,27,12,17,13,11,14,4,15,52,-1,-1},
    /*48*/{4,28,8,1,9,19,10,36,11,27,12,17,13,11,14,4,15,51,-1,-1},
    /*49*/{4,28,8,1,9,19,10,36,11,27,12,17,13,11,14,4,15,50,-1,-1},
    /*50*/{-1,-1},
    /*51*/{-1,-1},
    /*52*/{-1,-1},
    /*53*/{-1,-1},
    /*54*/{-1,-1},
    /*55*/{-1,-1},
    /*56*/{-1,-1},
    /*57*/{-1,-1},
    /*58*/{-1,-1},
    /*59*/{-1,-1},
    /*60*/{-1,-1},
    /*61*/{-1,-1},
    /*62*/{-1,-1},
    /*63*/{4,28,8,1,9,19,10,36,11,27,12,17,13,11,14,4,15,64,-1,-1},
    /*64*/{-1,-1},
    /*65*/{-1,-1},
    /*66*/{-1,-1},
    /*67*/{4,28,6,74,8,1,9,19,10,36,11,27,12,17,13,11,14,4,15,59,-1,-1},
    /*68*/{-1,-1},
    /*69*/{7,70,-1,-1},
    /*70*/{-1,-1},
    /*71*/{-1,-1},
    /*72*/{-1,-1},
    /*73*/{-1,-1},
    /*74*/{-1,-1},
    /*75*/{-1,-1},
    /*76*/{-1,-1},
    /*77*/{-1,-1},
    /*78*/{-1,-1},
    /*79*/{-1,-1},
    /*80*/{-1,-1},
    /*81*/{7,82,-1,-1},
    /*82*/{-1,-1},
    /*83*/{2,85,-1,-1},
    /*84*/{1,90,-1,-1},
    /*85*/{-1,-1},
    /*86*/{-1,-1},
    /*87*/{-1,-1},
    /*88*/{-1,-1},
    /*89*/{-1,-1},
    /*90*/{-1,-1},
    /*91*/{-1,-1},
    /*92*/{-1,-1},
    /*93*/{-1,-1},
    /*94*/{-1,-1},
    /*95*/{-1,-1},
    /*96*/{-1,-1},
    /*97*/{-1,-1},
    /*98*/{-1,-1},
    /*99*/{-1,-1},
    /*100*/{4,28,8,1,9,19,10,36,11,27,12,17,13,11,14,4,15,101,-1,-1},
    /*101*/{-1,-1},
    /*102*/{-1,-1},
    /*103*/{-1,-1},
    /*104*/{-1,-1},
    /*105*/{-1,-1},
    /*106*/{-1,-1},
    /*107*/{-1,-1},
    /*108*/{-1,-1},
    /*109*/{5,110,-1,-1},
    /*110*/{-1,-1},
    /*111*/{-1,-1},
    /*112*/{-1,-1},
    /*113*/{-1,-1},
    /*114*/{-1,-1},
    /*115*/{-1,-1},
    /*116*/{-1,-1},
    /*117*/{-1,-1},
    /*118*/{-1,-1},
    /*119*/{-1,-1},
    /*120*/{4,28,8,1,9,19,10,36,11,27,12,17,13,11,14,4,15,121,-1,-1},
    /*121*/{-1,-1},
    /*122*/{-1,-1},
    /*123*/{-1,-1},
    /*124*/{-1,-1},
    /*125*/{-1,-1},
    /*126*/{-1,-1},
    /*127*/{-1,-1},
    /*128*/{7,129,-1,-1},
    /*129*/{-1,-1},
    /*130*/{-1,-1},
    /*131*/{-1,-1},
    /*132*/{-1,-1},
    /*133*/{-1,-1},
    /*134*/{-1,-1},
    /*135*/{-1,-1},
    /*136*/{-1,-1},
    /*137*/{-1,-1},
    /*138*/{-1,-1},
    /*139*/{7,140,-1,-1},
    /*140*/{-1,-1},
    /*141*/{2,142,-1,-1},
    /*142*/{-1,-1},
    /*143*/{-1,-1},
    /*144*/{-1,-1},
    /*145*/{-1,-1},
    /*146*/{-1,-1},
    /*147*/{-1,-1},
    /*148*/{-1,-1},
    /*149*/{-1,-1},
    /*150*/{-1,-1},
  };

  /** access to reduce_goto table */
  public short[][] reduce_table() {return _reduce_table;}

  /** instance of action encapsulation class */
  protected CUP$GEparser$actions action_obj;

  /** action encapsulation object initializer */
  protected void init_actions()
    {
      action_obj = new CUP$GEparser$actions();
    }

  /** invoke a user supplied parse action */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$GEparser$do_action(act_num, parser, stack, top);
  }

  /** start state */
  public int start_state() {return 0;}
  /** start production */
  public int start_production() {return 1;}

  /** EOF Symbol index */
  public int EOF_sym() {return 0;}

  /** error Symbol index */
  public int error_sym() {return 1;}


  /** user initialization */
  public void user_init() throws java.lang.Exception
    {
 /* ... */ 
    }

  /** scan to get the next Symbol */
  public java_cup.runtime.Symbol scan()
    throws java.lang.Exception
    {
 return( ThisLexAnal.scanSymbol( ) ); 
    }

 

public final boolean parseAll( FlexString Instr , HighLevelBinTree ParseTree , 
			int MyMode )
			
/*
Fun: Given an expression, generates its parse tree.
In: Character string Instr to be parsed.
Out: Parse tree.  Returns true iff. there is an error.
Pre: None.
Post: Parse tree is returned in ParseTree.  If there's an error, the parse tree is
	empty.
Programmed By: Thorn Green.
*/

	{
	LexAnal MyLex = /* MyLexAnal; */ getLexAnal( Instr );
	boolean err = true;

	MyLex.initSymbolMode( Instr , MyMode );
	Symbol MySym = null;
	ErrCode = EngineConstants.SYNTAX_ERROR;

	try{
	MySym = parse();
	HighLevelBinTree MyTree = (HighLevelBinTree)( MySym.value );
	MyTree.copyDataPlusPtrInfo( ParseTree );
	err = false;
	} catch( Exception e ) { }

	
	return( err );
	};
	
		public final boolean verifyVariable( FlexString VarStr , int MyMode )
		
/*
Fun: Verifies that VarStr contains a valid name for a variable.
In: String VarStr, and the parsing mode.
Out: Boolean value.
Pre: VarStr, MyMode valid.
Post: If VarStr holds a variable, the value one will be returned.  Otherwise zero
	will be returned.
Programmed By: Thorn Green
*/
		
	{
	/* LexAnal MyLex = MyLexAnal; */
	boolean MyBool = /* MyLex. */ LexAnal.verifyVariable( VarStr , MyMode );
	return( MyBool );
	};
	
		public final void extractVariable( FlexString instr , int strt ,
			int endloc , FlexString outstr )
			
/*
Fun: Extracts an machine variable name from a string containing a variable name.
In: The string containing the variable name, the start of the variable name, the
	end of the variable name.
Out: Output string.
Pre: The string must contain a variable name at position [ strt , endloc ].
Post: The machine name of the variable will be placed in outstr.
Programmed By: Thorn Green
*/

	{
	/* LexAnal MyLex = MyLexAnal; */
	/* MyLex. */ LexAnal.extractVariable( instr , strt , endloc , outstr );
	};
	
		public final void clear( )
		
/*
Fun: Releases all memory allocated by the analyzer.
In: None.
Out: None.
Pre: None.
Post: All nodes allocated by this class will be cleared.
Programmed By: Thorn Green.
*/

	{
	/* LexAnal MyLex = MyLexAnal;
	MyLex.clear();
	MyList.eraseAllInfo(); */
	};
	
		public final int getErrCode( )
			{ return( ErrCode ); };

private final static LexAnal getLexAnal( FlexString in )
			{
			if( ThisLexAnal == null )
				{
				ThisLexAnal = new LexAnal( in );
				}
				else
				{
				ThisLexAnal.resetLexer( in );
				}

			return( ThisLexAnal );
			}

static LexAnal ThisLexAnal = null;
private int ErrCode;


}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$GEparser$actions {






	//$$strtCprt
	/**
	* Vector Victor -- Graphing Calculator Program For Android
	* 
	* Copyright (C) 1993-2013 Thornton Green
	* 
	* This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as
	* published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.
	* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty 
	* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
	* You should have received a copy of the GNU General Public License along with this program; if not, 
	* see <http://www.gnu.org/licenses>.
	* Additional permission under GNU GPL version 3 section 7
	*
	* If you modify this Program, or any covered work, by linking or combining it with Android 
	* (or a modified version of that library), containing parts covered by the terms of the Android licenses, 
	* the licensors of this Program grant you additional permission to convey the resulting work. {Corresponding Source for
	* a non-source form of such a combination shall include the source code for the parts of Android used as well 
	* as that of the covered work.}
	* 
	* If you modify this Program, or any covered work, by linking or combining it with Dexmaker 
	* (or a modified version of that library), containing parts covered by the terms of Apache License 2.0, 
	* the licensors of this Program grant you additional permission to convey the resulting work. {Corresponding Source for
	* a non-source form of such a combination shall include the source code for the parts of Dexmaker used as well 
	* as that of the covered work.}
	* 
	* If you modify this Program, or any covered work, by linking or combining it with JLex 
	* (or a modified version of that library), containing parts covered by the terms of JLex license listed below, 
	* the licensors of this Program grant you additional permission to convey the resulting work. {Corresponding Source for
	* a non-source form of such a combination shall include the source code for the parts of JLex used as well 
	* as that of the covered work.}
	* 
	* If you modify this Program, or any covered work, by linking or combining it with Java CUP 
	* (or a modified version of that library), containing parts covered by the terms of Java CUP license listed below, 
	* the licensors of this Program grant you additional permission to convey the resulting work. {Corresponding Source for
	* a non-source form of such a combination shall include the source code for the parts of Java CUP used as well 
	* as that of the covered work.}
	* 
	* If you modify this Program, or any covered work, by linking or combining it with TwoDScrollView 
	* (or a modified version of that library), containing parts covered by the terms of Apache License 2.0, 
	* the licensors of this Program grant you additional permission to convey the resulting work. {Corresponding Source for
	* a non-source form of such a combination shall include the source code for the parts of TwoDScrollView used as well 
	* as that of the covered work.}
	*
	*
	* Android is available at http://android.com
	*
	* Dexmaker is available at https://code.google.com/p/dexmaker/
	*
	* JLex is available at http://freecode.com/projects/jlex
	* 
	* Java CUP is available at http://www2.cs.turn.edu/projects/cup/
	* 
	* TwoDScrollView is available at http://blog.gorges.us/2010/06/android-two-dimensional-scrollview/
	*
	*
	* The licenses for Java CUP and JLex are listed below:
	* 
	* ****************************************************************************
	*
	* JLex COPYRIGHT NOTICE, LICENSE AND DISCLAIMER. 
	*
	* Copyright 1996 by Elliot Joel Berk. 
	*
	* Permission to use, copy, modify, and distribute this software and its documentation for any 
	* purpose and without fee is hereby granted, provided that the above copyright notice appear 
	* in all copies and that both the copyright notice and this permission notice and warranty 
	* disclaimer appear in supporting documentation, and that the name of Elliot Joel Berk not be 
	* used in advertising or publicity pertaining to distribution of the software without specific, 
	* written prior permission. 
	*
	* Elliot Joel Berk disclaims all warranties with regard to this software, including all implied 
	* warranties of merchantability and fitness. In no event shall Elliot Joel Berk be liable for 
	* any special, indirect or consequential damages or any damages whatsoever resulting from loss 
	* of use, data or profits, whether in an action of contract, negligence or other tortious 
	* action, arising out of or in connection with the use or performance of this software. 
	* 
	* ********************************************************************************
	*
	* CUP Parser Generator Copyright Notice, License, and Disclaimer
	* 
	* Copyright 1996-1999 by Scott Hudson, Frank Flannery, C. Scott Ananian 
	* 
	* Permission to use, copy, modify, and distribute this software and its documentation for any 
	* purpose and without fee is hereby granted, provided that the above copyright notice appear 
	* in all copies and that both the copyright notice and this permission notice and warranty 
	* disclaimer appear in supporting documentation, and that the names of the authors or their 
	* employers not be used in advertising or publicity pertaining to distribution of the software 
	* without specific, written prior permission. 
	* 
	* The authors and their employers disclaim all warranties with regard to this software, 
	* including all implied warranties of merchantability and fitness. In no event shall the 
	* authors or their employers be liable for any special, indirect or consequential damages or 
	* any damages whatsoever resulting from loss of use, data or profits, whether in an action of 
	* contract, negligence or other tortious action, arising out of or in connection with the use 
	* or performance of this software.
	*
	* ******************************************************************************
	*
	*
	*/
	//$$endCprt



/**
*
* --- SOURCE MODIFICATION LIST ---
*
* Please document all changes to this source file here.
* Feel free to add rows if needed.
*
*
*    |-----------------------|-------------------------------------------------|----------------------------------------------------------------------|---------------------------------------------------------------...
*    | Date of Modification  |    Author of Modification                       |    Reason for Modification                                           |    Description of Modification (use multiple rows if needed)  ... 
*    |-----------------------|-------------------------------------------------|----------------------------------------------------------------------|---------------------------------------------------------------...
*    |                       |                                                 |                                                                      |
*    | 9/24/2000             | Thorn Green (viridian_1138@yahoo.com)           | Needed to provide a standard way to document source file changes.    | Added a souce modification list to the documentation so that changes to the souce could be recorded. 
*    | 10/22/2000            | Thorn Green (viridian_1138@yahoo.com)           | Methods did not have names that followed standard Java conventions.  | Performed a global modification to bring the names within spec.
*    | 10/29/2000            | Thorn Green (viridian_1138@yahoo.com)           | Classes did not have names that followed standard Java conventions.  | Performed a global modification to bring the names within spec.
*    | 01/15/2002            | Thorn Green (viridian_1138@yahoo.com)           | Parse errors in DeCast productions were not being propagated.        | Added exception throwing to the production handlers.
*    | 07/19/2002            | Thorn Green (viridian_1138@yahoo.com)           | Needed to make GeomEngine competitive with John Cupani's E2D.        | Made parsing changes to improve performance.
*    | 08/07/2004            | Thorn Green (viridian_1138@yahoo.com)           | Establish baseline for all changes in the last year.                 | Establish baseline for all changes in the last year.
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*
*
*/



protected HighLevelBinTree newTreeNode( Lexeme ThisLex )

	{
	HighLevelBinTree MyTree = new HighLevelBinTree();

	MyTree.addRight( ThisLex );
	MyTree.setCopyMode( Meta.COPY_DO_NOTHING );
	MyTree.setEraseMode( Meta.WAKE );
		
	return( MyTree );
	};


protected HighLevelBinTree standardUnary( Lexeme FunLex , HighLevelBinTree TempTree )
	{
	HighLevelBinTree MyTree = new HighLevelBinTree();

	MyTree.addRight( FunLex );
	MyTree.setCopyMode( Meta.COPY_DO_NOTHING );
	MyTree.setEraseMode( Meta.WAKE );
	TempTree.connectLeft( MyTree );
	
	return( MyTree );
	}


protected HighLevelBinTree negationOp( Lexeme ThisLex , HighLevelBinTree TempTree )
	{
	HighLevelBinTree MyTree = standardUnary( ThisLex , TempTree );
	ThisLex.setMyMatch( GEval.negation );
	return( MyTree );
	}


protected HighLevelBinTree sequestOP( Lexeme Lex , HighLevelBinTree T1 , HighLevelBinTree T2 )
	{
	int Tval = 0;

	HighLevelBinTree OutTree = new HighLevelBinTree();
	HighLevelBinTree MyTree = new HighLevelBinTree();

	boolean Done = false;
	HighLevelBinTree TempTree = new HighLevelBinTree();
	T2.copyDataPlusPtrInfo( TempTree );

	if( !( TempTree.empty() ) )
		{
		while( !Done )
			{
			Lexeme KLex = (Lexeme)( ( TempTree ).getNode() );

			Mvec Kvec = KLex.getMvec();
			int kval = (int)( Kvec.getBasis() );
			if( kval == 0 ) { Tval = Tval | 1; }
			if( kval == 1 ) { Tval = Tval | 6; }
			if( kval == 2 ) { Tval = Tval | 8; }

			TempTree.right();
			Done = TempTree.equal( T2 );
			}
		}


	Lex.setPlugMatch( Tval );

	OutTree.addRight( Lex );
	OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
	OutTree.setEraseMode( Meta.WAKE );
	OutTree.copyDataPlusPtrInfo( MyTree );
	T1.connectLeft( OutTree );
	return( MyTree );
	}


protected HighLevelBinTree binOp( HighLevelBinTree Left , Lexeme Op , HighLevelBinTree Right )
	{
	HighLevelBinTree MyTree = new HighLevelBinTree();
	HighLevelBinTree NumTree = new HighLevelBinTree();

	MyTree.addRight( Op );
	MyTree.setCopyMode( Meta.COPY_DO_NOTHING );
	MyTree.setEraseMode( Meta.WAKE );
	Left.connectLeft( MyTree );
	MyTree.copyDataPlusPtrInfo( NumTree );
	NumTree.left();
	Right.connectRight( NumTree );

	return( MyTree );
	}


private final int countRight( HighLevelBinTree in )
	{
	int cnt = 0;
	boolean Done = false;
	HighLevelBinTree TempTree = new HighLevelBinTree();
	in.copyDataPlusPtrInfo( TempTree );

	if( !( TempTree.empty() ) )
		{
		while( !Done )
			{
			TempTree.right();
			cnt++;
			Done = TempTree.equal( in );
			}
		}

	return( cnt );
	}


private final int countList( HighLevelList in )
	{
	int cnt = 0;
	boolean Done = false;
	HighLevelList TempList = new HighLevelList();
	in.copyDataPlusPtrInfo( TempList );

	if( !( TempList.empty() ) )
		{
		TempList.searchHead();

		while( !Done )
			{
			TempList.right();
			cnt++;
			Done = TempList.getHead();
			}
		}

	return( cnt );
	}


protected HighLevelBinTree deCastLeft( Lexeme e1 , HighLevelBinTree e2 , HighLevelBinTree e3 , 
	Lexeme e4 , Lexeme e5 ) throws Exception
	{
	HighLevelBinTree MyTree = new HighLevelBinTree();
	HighLevelBinTree OutTree = new HighLevelBinTree();
	int NumBi = 0;
	int NumUr = 0;
	int Idex = 0;
	boolean err = false;
	Lexeme ThisLex = null;
	int ErrCode = 0;

	if( !err )
		{
		NumBi = countRight( e2 );
		NumUr = (int)( ( e5 ).getMvec().getBasis() );
		Idex = (int)( ( e4 ).getMvec().getBasis() );

		if( ( NumBi < ( NumUr + 1 ) ) ||
			( Idex >= ( NumBi - NumUr ) ) ||
			( Idex < 0 ) )
			{
			err = true;
			ErrCode = EngineConstants.ARGUMENT_MISMATCH;
			}

		}

	
	if( !err )
		{
		ObjObj ooBi = new ObjObj();
		ObjObj ooRes = new ObjObj();
		ObjObj ooTmp = new ObjObj();

		ooBi.value = new Mvec[ NumBi ];
		Mvec oR[] = new Mvec[ NumBi ]; ooRes.value = oR;
		Mvec oT[] = new Mvec[ NumBi ]; ooTmp.value = oT;

		int count;
		for( count = 0 ; count < NumBi ; ++count )
			{
			oR[ count ] = new Mvec();
			oT[ count ] = new Mvec();
			}

		ObjObj ooiv = new ObjObj();
		int[] ival = { NumBi , NumUr , Idex };
		ooiv.value = ival;
		e1.setMetaPtr( ooiv );
		

		OutTree.addRight( e1 );
		OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
		OutTree.setEraseMode( Meta.WAKE );
		OutTree.copyDataPlusPtrInfo( MyTree );
		

		( e3 ).connectLeft( OutTree );
	
		OutTree.left();
		while( !( OutTree.rThread() ) ) OutTree.right();

		( e2 ).connectRight( OutTree );
		
		while( !( OutTree.rThread() ) ) OutTree.right();
		
		




		ThisLex = new Lexeme();
		ThisLex.setMyMatch( GEval.CompObj );
		ThisLex.setMetaPtr( ooTmp );
		OutTree.addRight( ThisLex );
		OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
		OutTree.setEraseMode( Meta.WAKE );

		ThisLex = new Lexeme();
		ThisLex.setMyMatch( GEval.CompObj );
		ThisLex.setMetaPtr( ooRes );
		OutTree.addRight( ThisLex );
		OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
		OutTree.setEraseMode( Meta.WAKE );

		ThisLex = new Lexeme();
		ThisLex.setMyMatch( GEval.CompObj );
		ThisLex.setMetaPtr( ooBi );
		OutTree.addRight( ThisLex );
		OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
		OutTree.setEraseMode( Meta.WAKE );
		
		}


	if( err )
		throw( new Exception( "Parse Failed" ) );

	return( MyTree );
	}


protected HighLevelBinTree deCastRight( Lexeme e1 , HighLevelBinTree e2 , HighLevelBinTree e3 , 
	Lexeme e4 , Lexeme e5 ) throws Exception
	{
	HighLevelBinTree MyTree = new HighLevelBinTree();
	HighLevelBinTree OutTree = new HighLevelBinTree();
	int NumBi = 0;
	int NumUr = 0;
	int Idex = 0;
	boolean err = false;
	Lexeme ThisLex = null;
	int ErrCode = 0;

	if( !err )
		{
		NumBi = countRight( e2 );
		NumUr = (int)( ( e5 ).getMvec().getBasis() );
		Idex = (int)( ( e4 ).getMvec().getBasis() );

		if( ( NumBi < ( NumUr + 1 ) ) ||
			( Idex >= ( NumBi - NumUr ) ) ||
			( Idex < 0 ) )
			{
			err = true;
			ErrCode = EngineConstants.ARGUMENT_MISMATCH;
			}

		}

	
	if( !err )
		{
		ObjObj ooBi = new ObjObj();
		ObjObj ooRes = new ObjObj();
		ObjObj ooTmp = new ObjObj();

		ooBi.value = new Mvec[ NumBi ];
		Mvec oR[] = new Mvec[ NumBi ]; ooRes.value = oR;
		Mvec oT[] = new Mvec[ NumBi ]; ooTmp.value = oT;

		int count;
		for( count = 0 ; count < NumBi ; ++count )
			{
			oR[ count ] = new Mvec();
			oT[ count ] = new Mvec();
			}

		ObjObj ooiv = new ObjObj();
		int[] ival = { NumBi , NumUr , Idex };
		ooiv.value = ival;
		e1.setMetaPtr( ooiv );
		

		OutTree.addRight( e1 );
		OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
		OutTree.setEraseMode( Meta.WAKE );
		OutTree.copyDataPlusPtrInfo( MyTree );
		

		( e3 ).connectLeft( OutTree );
	
		OutTree.left();
		while( !( OutTree.rThread() ) ) OutTree.right();

		( e2 ).connectRight( OutTree );
		
		while( !( OutTree.rThread() ) ) OutTree.right();
		
		




		ThisLex = new Lexeme();
		ThisLex.setMyMatch( GEval.CompObj );
		ThisLex.setMetaPtr( ooTmp );
		OutTree.addRight( ThisLex );
		OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
		OutTree.setEraseMode( Meta.WAKE );

		ThisLex = new Lexeme();
		ThisLex.setMyMatch( GEval.CompObj );
		ThisLex.setMetaPtr( ooRes );
		OutTree.addRight( ThisLex );
		OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
		OutTree.setEraseMode( Meta.WAKE );

		ThisLex = new Lexeme();
		ThisLex.setMyMatch( GEval.CompObj );
		ThisLex.setMetaPtr( ooBi );
		OutTree.addRight( ThisLex );
		OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
		OutTree.setEraseMode( Meta.WAKE );
		
		}


	if( err )
		throw( new Exception( "Parse Failed" ) );

	return( MyTree );
	}


protected HighLevelBinTree deCastBlossomLeft( Lexeme e1 , HighLevelBinTree e2 , HighLevelBinTree e3 , 
	Lexeme e4 ) throws Exception
	{
	HighLevelBinTree MyTree = new HighLevelBinTree();
	HighLevelBinTree OutTree = new HighLevelBinTree();
	int NumBi = 0;
	int NumUr = 0;
	int Idex = 0;
	boolean err = false;
	Lexeme ThisLex = null;
	int ErrCode = 0;

	if( !err )
		{
		NumBi = countRight( e2 );
		NumUr = countRight( e3 );
		Idex = (int)( ( e4 ).getMvec().getBasis() );

		if( ( NumBi < ( NumUr + 1 ) ) ||
			( Idex >= ( NumBi - NumUr ) ) ||
			( Idex < 0 ) )
			{
			err = true;
			ErrCode = EngineConstants.ARGUMENT_MISMATCH;
			}

		}


	if( !err )
		{							
		ObjObj ooBi = new ObjObj();
		ObjObj ooRes = new ObjObj();
		ObjObj ooTmp = new ObjObj();
		ObjObj ooUr = new ObjObj();

		ooBi.value = new Mvec[ NumBi ];
		Mvec oR[] = new Mvec[ NumBi ]; ooRes.value = oR;
		Mvec oT[] = new Mvec[ NumBi ]; ooTmp.value = oT;
		ooUr.value = new Mvec[ NumUr ];

		int count;
		for( count = 0 ; count < NumBi ; ++count )
			{
			oR[ count ] = new Mvec();
			oT[ count ] = new Mvec();
			}

		ObjObj ooiv = new ObjObj();
		int[] ival = { NumBi , NumUr , Idex };
		ooiv.value = ival;
		e1.setMetaPtr( ooiv );

		OutTree.addRight( e1 );
		OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
		OutTree.setEraseMode( Meta.WAKE );
		OutTree.copyDataPlusPtrInfo( MyTree );



		( e3 ).connectLeft( OutTree );
	
		OutTree.left();
		while( !( OutTree.rThread() ) ) OutTree.right();

		( e2 ).connectRight( OutTree );
		
		while( !( OutTree.rThread() ) ) OutTree.right();
		
		


		ThisLex = new Lexeme();
		ThisLex.setMyMatch( GEval.CompObj );
		ThisLex.setMetaPtr( ooUr );
		OutTree.addRight( ThisLex );
		OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
		OutTree.setEraseMode( Meta.WAKE );


		ThisLex = new Lexeme();
		ThisLex.setMyMatch( GEval.CompObj );
		ThisLex.setMetaPtr( ooTmp );
		OutTree.addRight( ThisLex );
		OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
		OutTree.setEraseMode( Meta.WAKE );

		ThisLex = new Lexeme();
		ThisLex.setMyMatch( GEval.CompObj );
		ThisLex.setMetaPtr( ooRes );
		OutTree.addRight( ThisLex );
		OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
		OutTree.setEraseMode( Meta.WAKE );

		ThisLex = new Lexeme();
		ThisLex.setMyMatch( GEval.CompObj );
		ThisLex.setMetaPtr( ooBi );
		OutTree.addRight( ThisLex );
		OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
		OutTree.setEraseMode( Meta.WAKE );
		}


	if( err )
		throw( new Exception( "Parse Failed" ) );

	return( MyTree );
	}


protected HighLevelBinTree deCastBlossomRight( Lexeme e1 , HighLevelBinTree e2 , HighLevelBinTree e3 , 
	Lexeme e4 ) throws Exception
	{
	HighLevelBinTree MyTree = new HighLevelBinTree();
	HighLevelBinTree OutTree = new HighLevelBinTree();
	int NumBi = 0;
	int NumUr = 0;
	int Idex = 0;
	boolean err = false;
	Lexeme ThisLex = null;
	int ErrCode = 0;

	if( !err )
		{
		NumBi = countRight( e2 );
		NumUr = countRight( e3 );
		Idex = (int)( ( e4 ).getMvec().getBasis() );

		if( ( NumBi < ( NumUr + 1 ) ) ||
			( Idex >= ( NumBi - NumUr ) ) ||
			( Idex < 0 ) )
			{
			err = true;
			ErrCode = EngineConstants.ARGUMENT_MISMATCH;
			}

		}


	if( !err )
		{							
		ObjObj ooBi = new ObjObj();
		ObjObj ooRes = new ObjObj();
		ObjObj ooTmp = new ObjObj();
		ObjObj ooUr = new ObjObj();

		ooBi.value = new Mvec[ NumBi ];
		Mvec oR[] = new Mvec[ NumBi ]; ooRes.value = oR;
		Mvec oT[] = new Mvec[ NumBi ]; ooTmp.value = oT;
		ooUr.value = new Mvec[ NumUr ];

		int count;
		for( count = 0 ; count < NumBi ; ++count )
			{
			oR[ count ] = new Mvec();
			oT[ count ] = new Mvec();
			}

		ObjObj ooiv = new ObjObj();
		int[] ival = { NumBi , NumUr , Idex };
		ooiv.value = ival;
		e1.setMetaPtr( ooiv );

		OutTree.addRight( e1 );
		OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
		OutTree.setEraseMode( Meta.WAKE );
		OutTree.copyDataPlusPtrInfo( MyTree );



		( e3 ).connectLeft( OutTree );
	
		OutTree.left();
		while( !( OutTree.rThread() ) ) OutTree.right();

		( e2 ).connectRight( OutTree );
		
		while( !( OutTree.rThread() ) ) OutTree.right();
		
		


		ThisLex = new Lexeme();
		ThisLex.setMyMatch( GEval.CompObj );
		ThisLex.setMetaPtr( ooUr );
		OutTree.addRight( ThisLex );
		OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
		OutTree.setEraseMode( Meta.WAKE );


		ThisLex = new Lexeme();
		ThisLex.setMyMatch( GEval.CompObj );
		ThisLex.setMetaPtr( ooTmp );
		OutTree.addRight( ThisLex );
		OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
		OutTree.setEraseMode( Meta.WAKE );

		ThisLex = new Lexeme();
		ThisLex.setMyMatch( GEval.CompObj );
		ThisLex.setMetaPtr( ooRes );
		OutTree.addRight( ThisLex );
		OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
		OutTree.setEraseMode( Meta.WAKE );

		ThisLex = new Lexeme();
		ThisLex.setMyMatch( GEval.CompObj );
		ThisLex.setMetaPtr( ooBi );
		OutTree.addRight( ThisLex );
		OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
		OutTree.setEraseMode( Meta.WAKE );
		}


	if( err )
		throw( new Exception( "Parse Failed" ) );

	return( MyTree );
	}


protected HighLevelBinTree deCastBlossomLeftComp( Lexeme e1 , HighLevelBinTree e2 , HighLevelBinTree e3 , 
	HighLevelList e4 , Lexeme e5 ) throws Exception
	{
	HighLevelBinTree MyTree = new HighLevelBinTree();
	HighLevelBinTree OutTree = new HighLevelBinTree();
	int NumBi = 0;
	int NumUl = 0;
	int NumUr = 0;
	int Idex = 0;
	boolean err = false;
	Lexeme ThisLex = null;
	int ErrCode = 0;

	if( !err )
		{
		NumBi = countRight( e2 );
		NumUl = countRight( e3 );
		NumUr = countList( e4 );
		Idex = (int)( ( e5 ).getMvec().getBasis() );

		if( ( NumUl != NumUr ) ||
			( NumBi < ( NumUl + 1 ) ) ||
			( Idex >= ( NumBi - NumUl ) ) ||
			( Idex < 0 ) )
			{
			err = true;
			ErrCode = EngineConstants.ARGUMENT_MISMATCH;
			}

		}


	if( !err )
		{							
		ObjObj ooBi = new ObjObj();
		ObjObj ooRes = new ObjObj();
		ObjObj ooTmp = new ObjObj();
		ObjObj ooUl = new ObjObj();
		ObjObj ooUr = new ObjObj();

		int[] ival = new int[ NumUr + 3 ];


		ooBi.value = new Mvec[ NumBi ];
		Mvec oR[] = new Mvec[ NumBi ]; ooRes.value = oR;
		Mvec oT[] = new Mvec[ NumBi ]; ooTmp.value = oT;
		Mvec oUl[] = new Mvec[ NumUl ]; ooUl.value = oUl;
		ooUr.value = new Mvec[ NumUr ];

		int count;
		for( count = 0 ; count < NumBi ; ++count )
			{
			oR[ count ] = new Mvec();
			oT[ count ] = new Mvec();
			}

		e4.searchHead();
		for( count = 0 ; count < NumUr ; ++count )
			{
			oUl[ count ] = new Mvec();
			Lexeme MyLex = (Lexeme)( e4.getNode() );
			FlexString MyStr = (FlexString)( MyLex.getMetaPtr() );
			ival[ count + 3 ] = 0;
			if( MyStr.getChar( 1 ) == 'v' )
				ival[ count + 3 ] = 1;
			e4.right();
			}

		ObjObj ooiv = new ObjObj();
		ival[ 0 ] = NumBi;
		ival[ 1 ] = NumUr;
		ival[ 2 ] = Idex;
		ooiv.value = ival;
		e1.setMetaPtr( ooiv );

		OutTree.addRight( e1 );
		OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
		OutTree.setEraseMode( Meta.WAKE );
		OutTree.copyDataPlusPtrInfo( MyTree );



		( e3 ).connectLeft( OutTree );

		OutTree.left();	
		while( !( OutTree.rThread() ) ) OutTree.right();

		( e2 ).connectRight( OutTree );
		
		while( !( OutTree.rThread() ) ) OutTree.right();
		
		


		ThisLex = new Lexeme();
		ThisLex.setMyMatch( GEval.CompObj );
		ThisLex.setMetaPtr( ooUr );
		OutTree.addRight( ThisLex );
		OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
		OutTree.setEraseMode( Meta.WAKE );

		ThisLex = new Lexeme();
		ThisLex.setMyMatch( GEval.CompObj );
		ThisLex.setMetaPtr( ooUl );
		OutTree.addRight( ThisLex );
		OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
		OutTree.setEraseMode( Meta.WAKE );

		ThisLex = new Lexeme();
		ThisLex.setMyMatch( GEval.CompObj );
		ThisLex.setMetaPtr( ooTmp );
		OutTree.addRight( ThisLex );
		OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
		OutTree.setEraseMode( Meta.WAKE );

		ThisLex = new Lexeme();
		ThisLex.setMyMatch( GEval.CompObj );
		ThisLex.setMetaPtr( ooRes );
		OutTree.addRight( ThisLex );
		OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
		OutTree.setEraseMode( Meta.WAKE );

		ThisLex = new Lexeme();
		ThisLex.setMyMatch( GEval.CompObj );
		ThisLex.setMetaPtr( ooBi );
		OutTree.addRight( ThisLex );
		OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
		OutTree.setEraseMode( Meta.WAKE );
		}

	e4.eraseAllInfo();

	if( err )
		throw( new Exception( "Parse Failed" ) );

	return( MyTree );
	}


protected HighLevelBinTree deCastBlossomRightComp( Lexeme e1 , HighLevelBinTree e2 , HighLevelBinTree e3 , 
	HighLevelList e4 , Lexeme e5 ) throws Exception
	{
	HighLevelBinTree MyTree = new HighLevelBinTree();
	HighLevelBinTree OutTree = new HighLevelBinTree();
	int NumBi = 0;
	int NumUl = 0;
	int NumUr = 0;
	int Idex = 0;
	boolean err = false;
	Lexeme ThisLex = null;
	int ErrCode = 0;

	if( !err )
		{
		NumBi = countRight( e2 );
		NumUl = countRight( e3 );
		NumUr = countList( e4 );
		Idex = (int)( ( e5 ).getMvec().getBasis() );

		if( ( NumUl != NumUr ) ||
			( NumBi < ( NumUl + 1 ) ) ||
			( Idex >= ( NumBi - NumUl ) ) ||
			( Idex < 0 ) )
			{
			err = true;
			ErrCode = EngineConstants.ARGUMENT_MISMATCH;
			}

		}


	if( !err )
		{							
		ObjObj ooBi = new ObjObj();
		ObjObj ooRes = new ObjObj();
		ObjObj ooTmp = new ObjObj();
		ObjObj ooUl = new ObjObj();
		ObjObj ooUr = new ObjObj();

		int[] ival = new int[ NumUr + 3 ];


		ooBi.value = new Mvec[ NumBi ];
		Mvec oR[] = new Mvec[ NumBi ]; ooRes.value = oR;
		Mvec oT[] = new Mvec[ NumBi ]; ooTmp.value = oT;
		Mvec oUl[] = new Mvec[ NumUl ]; ooUl.value = oUl;
		ooUr.value = new Mvec[ NumUr ];

		int count;
		for( count = 0 ; count < NumBi ; ++count )
			{
			oR[ count ] = new Mvec();
			oT[ count ] = new Mvec();
			}

		e4.searchHead();
		for( count = 0 ; count < NumUr ; ++count )
			{
			oUl[ count ] = new Mvec();
			Lexeme MyLex = (Lexeme)( e4.getNode() );
			FlexString MyStr = (FlexString)( MyLex.getMetaPtr() );
			ival[ count + 3 ] = 0;
			if( MyStr.getChar( 1 ) == 'v' )
				ival[ count + 3 ] = 1;
			e4.right();
			}

		ObjObj ooiv = new ObjObj();
		ival[ 0 ] = NumBi;
		ival[ 1 ] = NumUr;
		ival[ 2 ] = Idex;
		ooiv.value = ival;
		e1.setMetaPtr( ooiv );

		OutTree.addRight( e1 );
		OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
		OutTree.setEraseMode( Meta.WAKE );
		OutTree.copyDataPlusPtrInfo( MyTree );



		( e3 ).connectLeft( OutTree );

		OutTree.left();	
		while( !( OutTree.rThread() ) ) OutTree.right();

		( e2 ).connectRight( OutTree );
		
		while( !( OutTree.rThread() ) ) OutTree.right();
		
		


		ThisLex = new Lexeme();
		ThisLex.setMyMatch( GEval.CompObj );
		ThisLex.setMetaPtr( ooUr );
		OutTree.addRight( ThisLex );
		OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
		OutTree.setEraseMode( Meta.WAKE );

		ThisLex = new Lexeme();
		ThisLex.setMyMatch( GEval.CompObj );
		ThisLex.setMetaPtr( ooUl );
		OutTree.addRight( ThisLex );
		OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
		OutTree.setEraseMode( Meta.WAKE );

		ThisLex = new Lexeme();
		ThisLex.setMyMatch( GEval.CompObj );
		ThisLex.setMetaPtr( ooTmp );
		OutTree.addRight( ThisLex );
		OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
		OutTree.setEraseMode( Meta.WAKE );

		ThisLex = new Lexeme();
		ThisLex.setMyMatch( GEval.CompObj );
		ThisLex.setMetaPtr( ooRes );
		OutTree.addRight( ThisLex );
		OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
		OutTree.setEraseMode( Meta.WAKE );

		ThisLex = new Lexeme();
		ThisLex.setMyMatch( GEval.CompObj );
		ThisLex.setMetaPtr( ooBi );
		OutTree.addRight( ThisLex );
		OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
		OutTree.setEraseMode( Meta.WAKE );
		}

	e4.eraseAllInfo();

	if( err )
		throw( new Exception( "Parse Failed" ) );

	return( MyTree );
	}


protected HighLevelBinTree buildList( HighLevelBinTree e1 , HighLevelBinTree e2 )
	{
	e1.connectRight( e2 );
	return( e2 );
	}


protected HighLevelBinTree buildList( HighLevelBinTree e1 , Lexeme e2 )
	{
	HighLevelBinTree e2t = newTreeNode( e2 );
	return( buildList( e1 , e2t ) );
	}


protected HighLevelList buildStringList( HighLevelList e1 , Lexeme e2 )
	{
	e1.searchHead();
	e1.left();
	e1.insertRight( e2 );
	e1.setCopyMode( Meta.COPY_DO_NOTHING );
	e1.setEraseMode( Meta.WAKE );
	return( e1 );
	}


protected HighLevelList buildStringList( Lexeme e )
	{
	HighLevelList MyList = new HighLevelList();
	MyList.insertRight( e );
	MyList.setCopyMode( Meta.COPY_DO_NOTHING );
	MyList.setEraseMode( Meta.WAKE );
	return( MyList );
	}


protected HighLevelBinTree plugOp( Lexeme FunLex , HighLevelBinTree TempTree )
		throws java.lang.Exception
	{
	int count = 0;	
	HighLevelBinTree ret = null;
	java.util.Vector Plugs = GeomEngine.getPlugins();
	int len = Plugs.size();
	FlexString MyStr = (FlexString)( FunLex.getMetaPtr() );

	while( ( count < len ) && ( ret == null ) )
		{
		DepicPlugin MyPlug = (DepicPlugin)( Plugs.elementAt( count ) );
		ret = MyPlug.parseOps( MyStr , FunLex , TempTree );
		count++;
		}

	if( ret == null )
		throw new Exception( "No such plugin function found" );

	return( ret );
	}


 

  /** Constructor */
  CUP$GEparser$actions() { }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$GEparser$do_action(
    int                        CUP$GEparser$act_num,
    java_cup.runtime.lr_parser CUP$GEparser$parser,
    java.util.Stack            CUP$GEparser$stack,
    int                        CUP$GEparser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$GEparser$result;

      /* select the action based on the action number */
      switch (CUP$GEparser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // PLUG_EXPR ::= PlugOp Rparen 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		Lexeme e1 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		 RESULT = plugOp( e1 , null ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(14/*PLUG_EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // PLUG_EXPR ::= PlugOp EXPR_LIST Rparen 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).right;
		Lexeme e1 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		HighLevelBinTree e2 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		 RESULT = plugOp( e1 , e2 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(14/*PLUG_EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // FORM_EXPR ::= Lbrak EXPR_LIST Rbrak 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		HighLevelBinTree e1 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		 RESULT = e1; 
              CUP$GEparser$result = new java_cup.runtime.Symbol(7/*FORM_EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // FORM_STRING ::= Lbrak STRING_LIST Rbrak 
            {
              HighLevelList RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		HighLevelList e1 = (HighLevelList)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		 RESULT = e1; 
              CUP$GEparser$result = new java_cup.runtime.Symbol(2/*FORM_STRING*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // STRING_LIST ::= STRING_LIST Comma String 
            {
              HighLevelList RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).right;
		HighLevelList e1 = (HighLevelList)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		Lexeme e2 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = buildStringList( e1 , e2 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(1/*STRING_LIST*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // STRING_LIST ::= String 
            {
              HighLevelList RESULT = null;
		int eleft = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		Lexeme e = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = buildStringList( e ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(1/*STRING_LIST*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // EXPR_LIST ::= EXPR_LIST Comma EXPR 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).right;
		HighLevelBinTree e1 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		HighLevelBinTree e2 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = buildList( e1 , e2 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(6/*EXPR_LIST*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // EXPR_LIST ::= EXPR 
            {
              HighLevelBinTree RESULT = null;
		int eleft = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		HighLevelBinTree e = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = e; 
              CUP$GEparser$result = new java_cup.runtime.Symbol(6/*EXPR_LIST*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // CONST_LIST ::= CONST_LIST Comma NumConst 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).right;
		HighLevelBinTree e1 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		Lexeme e2 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = buildList( e1 , e2 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(5/*CONST_LIST*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // CONST_LIST ::= NumConst 
            {
              HighLevelBinTree RESULT = null;
		int eleft = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		Lexeme e = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = newTreeNode( e ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(5/*CONST_LIST*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // DECASTRIGHT ::= DeCastRight FORM_EXPR Comma EXPR Comma NumConst Comma NumConst Rparen 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-8)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-8)).right;
		Lexeme e1 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-8)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-7)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-7)).right;
		HighLevelBinTree e2 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-7)).value;
		int e3left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-5)).left;
		int e3right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-5)).right;
		HighLevelBinTree e3 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-5)).value;
		int e4left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-3)).left;
		int e4right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-3)).right;
		Lexeme e4 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-3)).value;
		int e5left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e5right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		Lexeme e5 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		 RESULT = deCastRight( e1 , e2 , e3 , e4 , e5 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(13/*DECASTRIGHT*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-8)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // DECASTLEFT ::= DeCastLeft FORM_EXPR Comma EXPR Comma NumConst Comma NumConst Rparen 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-8)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-8)).right;
		Lexeme e1 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-8)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-7)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-7)).right;
		HighLevelBinTree e2 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-7)).value;
		int e3left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-5)).left;
		int e3right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-5)).right;
		HighLevelBinTree e3 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-5)).value;
		int e4left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-3)).left;
		int e4right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-3)).right;
		Lexeme e4 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-3)).value;
		int e5left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e5right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		Lexeme e5 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		 RESULT = deCastLeft( e1 , e2 , e3 , e4 , e5 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(12/*DECASTLEFT*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-8)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // DECASTBLOSSOMRIGHT ::= DeCastBlossomRight FORM_EXPR Comma FORM_EXPR Comma NumConst Rparen 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-6)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-6)).right;
		Lexeme e1 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-6)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-5)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-5)).right;
		HighLevelBinTree e2 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-5)).value;
		int e3left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-3)).left;
		int e3right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-3)).right;
		HighLevelBinTree e3 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-3)).value;
		int e4left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e4right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		Lexeme e4 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		 RESULT = deCastBlossomRight( e1 , e2 , e3 , e4 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(11/*DECASTBLOSSOMRIGHT*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-6)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // DECASTBLOSSOMLEFT ::= DeCastBlossomLeft FORM_EXPR Comma FORM_EXPR Comma NumConst Rparen 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-6)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-6)).right;
		Lexeme e1 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-6)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-5)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-5)).right;
		HighLevelBinTree e2 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-5)).value;
		int e3left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-3)).left;
		int e3right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-3)).right;
		HighLevelBinTree e3 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-3)).value;
		int e4left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e4right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		Lexeme e4 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		 RESULT = deCastBlossomLeft( e1 , e2 , e3 , e4 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(10/*DECASTBLOSSOMLEFT*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-6)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // DECASTBLOSSOMLEFTCOMP ::= DeCastBlossomLeftComp FORM_EXPR Comma FORM_EXPR Comma FORM_STRING Comma NumConst Rparen 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-8)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-8)).right;
		Lexeme e1 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-8)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-7)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-7)).right;
		HighLevelBinTree e2 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-7)).value;
		int e3left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-5)).left;
		int e3right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-5)).right;
		HighLevelBinTree e3 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-5)).value;
		int e4left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-3)).left;
		int e4right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-3)).right;
		HighLevelList e4 = (HighLevelList)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-3)).value;
		int e5left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e5right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		Lexeme e5 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		 RESULT = deCastBlossomLeftComp( e1 , e2 , e3 , e4 , e5 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(8/*DECASTBLOSSOMLEFTCOMP*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-8)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // DECASTBLOSSOMRIGHTCOMP ::= DeCastBlossomRightComp FORM_EXPR Comma FORM_EXPR Comma FORM_STRING Comma NumConst Rparen 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-8)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-8)).right;
		Lexeme e1 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-8)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-7)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-7)).right;
		HighLevelBinTree e2 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-7)).value;
		int e3left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-5)).left;
		int e3right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-5)).right;
		HighLevelBinTree e3 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-5)).value;
		int e4left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-3)).left;
		int e4right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-3)).right;
		HighLevelList e4 = (HighLevelList)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-3)).value;
		int e5left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e5right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		Lexeme e5 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		 RESULT = deCastBlossomRightComp( e1 , e2 , e3 , e4 , e5 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(9/*DECASTBLOSSOMRIGHTCOMP*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-8)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // SEQUEST ::= Lbrac EXPR Rbrac Lbrak CONST_LIST Rbrak 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-5)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-5)).right;
		Lexeme e1 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-5)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-4)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-4)).right;
		HighLevelBinTree e2 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-4)).value;
		int e3left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e3right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		HighLevelBinTree e3 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		 RESULT = sequestOP( e1 , e2 , e3 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(4/*SEQUEST*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-5)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // EXPR ::= variable 
            {
              HighLevelBinTree RESULT = null;
		int eleft = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		Lexeme e = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = newTreeNode( e ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // EXPR ::= NumConst 
            {
              HighLevelBinTree RESULT = null;
		int eleft = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		Lexeme e = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = newTreeNode( e ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // EXPR ::= pi 
            {
              HighLevelBinTree RESULT = null;
		int eleft = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		Lexeme e = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = newTreeNode( e ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // EXPR ::= basis12 
            {
              HighLevelBinTree RESULT = null;
		int eleft = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		Lexeme e = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = newTreeNode( e ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // EXPR ::= basis2 
            {
              HighLevelBinTree RESULT = null;
		int eleft = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		Lexeme e = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = newTreeNode( e ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // EXPR ::= basis1 
            {
              HighLevelBinTree RESULT = null;
		int eleft = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		Lexeme e = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = newTreeNode( e ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // EXPR ::= PLUG_EXPR 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		HighLevelBinTree e1 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = e1; 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // EXPR ::= DECASTRIGHT 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		HighLevelBinTree e1 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = e1; 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // EXPR ::= DECASTLEFT 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		HighLevelBinTree e1 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = e1; 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // EXPR ::= DECASTBLOSSOMRIGHT 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		HighLevelBinTree e1 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = e1; 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // EXPR ::= DECASTBLOSSOMLEFT 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		HighLevelBinTree e1 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = e1; 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // EXPR ::= DECASTBLOSSOMRIGHTCOMP 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		HighLevelBinTree e1 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = e1; 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // EXPR ::= DECASTBLOSSOMLEFTCOMP 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		HighLevelBinTree e1 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = e1; 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // EXPR ::= SEQUEST 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		HighLevelBinTree e1 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = e1; 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // EXPR ::= ln EXPR Rparen 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).right;
		Lexeme e1 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		HighLevelBinTree e2 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		 RESULT = standardUnary( e1 , e2 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // EXPR ::= UnitOf EXPR Rparen 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).right;
		Lexeme e1 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		HighLevelBinTree e2 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		 RESULT = standardUnary( e1 , e2 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // EXPR ::= PhasToVect EXPR Rparen 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).right;
		Lexeme e1 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		HighLevelBinTree e2 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		 RESULT = standardUnary( e1 , e2 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // EXPR ::= magnitude EXPR Rparen 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).right;
		Lexeme e1 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		HighLevelBinTree e2 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		 RESULT = standardUnary( e1 , e2 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // EXPR ::= inverse EXPR Rparen 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).right;
		Lexeme e1 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		HighLevelBinTree e2 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		 RESULT = standardUnary( e1 , e2 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // EXPR ::= reverse EXPR Rparen 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).right;
		Lexeme e1 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		HighLevelBinTree e2 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		 RESULT = standardUnary( e1 , e2 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // EXPR ::= cosh EXPR Rparen 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).right;
		Lexeme e1 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		HighLevelBinTree e2 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		 RESULT = standardUnary( e1 , e2 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // EXPR ::= sinh EXPR Rparen 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).right;
		Lexeme e1 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		HighLevelBinTree e2 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		 RESULT = standardUnary( e1 , e2 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // EXPR ::= sin EXPR Rparen 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).right;
		Lexeme e1 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		HighLevelBinTree e2 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		 RESULT = standardUnary( e1 , e2 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // EXPR ::= cos EXPR Rparen 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).right;
		Lexeme e1 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		HighLevelBinTree e2 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		 RESULT = standardUnary( e1 , e2 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // EXPR ::= exp EXPR Rparen 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).right;
		Lexeme e1 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		HighLevelBinTree e2 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		 RESULT = standardUnary( e1 , e2 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // EXPR ::= Lparen EXPR Rparen 
            {
              HighLevelBinTree RESULT = null;
		int eleft = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		HighLevelBinTree e = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		 RESULT = e; 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // EXPR ::= minus EXPR 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		Lexeme e1 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		HighLevelBinTree e2 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = negationOp( e1 , e2 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // EXPR ::= plus EXPR 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		HighLevelBinTree e1 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = e1; 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // EXPR ::= EXPR wedge EXPR 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).right;
		HighLevelBinTree e1 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		Lexeme e2 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		int e3left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int e3right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		HighLevelBinTree e3 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = binOp( e1 , e2 , e3 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // EXPR ::= EXPR cross EXPR 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).right;
		HighLevelBinTree e1 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		Lexeme e2 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		int e3left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int e3right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		HighLevelBinTree e3 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = binOp( e1 , e2 , e3 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // EXPR ::= EXPR dot EXPR 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).right;
		HighLevelBinTree e1 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		Lexeme e2 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		int e3left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int e3right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		HighLevelBinTree e3 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = binOp( e1 , e2 , e3 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // EXPR ::= EXPR div EXPR 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).right;
		HighLevelBinTree e1 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		Lexeme e2 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		int e3left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int e3right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		HighLevelBinTree e3 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = binOp( e1 , e2 , e3 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // EXPR ::= EXPR prod EXPR 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).right;
		HighLevelBinTree e1 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		Lexeme e2 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		int e3left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int e3right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		HighLevelBinTree e3 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = binOp( e1 , e2 , e3 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // EXPR ::= EXPR vminus EXPR 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).right;
		HighLevelBinTree e1 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		Lexeme e2 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		int e3left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int e3right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		HighLevelBinTree e3 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = binOp( e1 , e2 , e3 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // EXPR ::= EXPR vplus EXPR 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).right;
		HighLevelBinTree e1 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		Lexeme e2 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		int e3left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int e3right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		HighLevelBinTree e3 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = binOp( e1 , e2 , e3 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // EXPR ::= EXPR minus EXPR 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).right;
		HighLevelBinTree e1 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		Lexeme e2 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		int e3left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int e3right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		HighLevelBinTree e3 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = binOp( e1 , e2 , e3 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // EXPR ::= EXPR plus EXPR 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).right;
		HighLevelBinTree e1 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		Lexeme e2 = (Lexeme)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		int e3left = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int e3right = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		HighLevelBinTree e3 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = binOp( e1 , e2 , e3 ); 
              CUP$GEparser$result = new java_cup.runtime.Symbol(15/*EXPR*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // $START ::= LINE EOF 
            {
              Object RESULT = null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).right;
		HighLevelBinTree start_val = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).value;
		RESULT = start_val;
              CUP$GEparser$result = new java_cup.runtime.Symbol(0/*$START*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          /* ACCEPT */
          CUP$GEparser$parser.done_parsing();
          return CUP$GEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // LINE ::= EXPR 
            {
              HighLevelBinTree RESULT = null;
		int eleft = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right;
		HighLevelBinTree e = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).value;
		 RESULT = e; 
              CUP$GEparser$result = new java_cup.runtime.Symbol(3/*LINE*/, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$GEparser$stack.elementAt(CUP$GEparser$top-0)).right, RESULT);
            }
          return CUP$GEparser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

