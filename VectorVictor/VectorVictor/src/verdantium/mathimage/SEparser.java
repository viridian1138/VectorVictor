
//----------------------------------------------------
// The following code was generated by CUP v0.10g
// Sat Feb 19 08:13:51 MST 2005
//----------------------------------------------------

package verdantium.mathimage;

import java.util.Stack;

import java_cup.runtime.Symbol;
import meta.FlexString;
import meta.HighLevelBinTree;
import meta.Meta;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Path;
import android.graphics.RectF;
import android.graphics.Typeface;

public class SEparser extends java_cup.runtime.lr_parser {

  /** constructor */
  public SEparser() {super();}

  /** production table */
  protected static final short _production_table[][] = {
        {1, 1},     {0, 2},     {1, 0},     {5, 1},     {7, 1}, 
        {7, 2},     {6, 1},     {6, 2},     {2, 3},     {2, 3}, 
        {8, 0},     {2, 4},     {9, 0},     {2, 4},     {10, 0}, 
        {2, 4},     {2, 3},     {11, 0},     {2, 4},     {2, 3}, 
        {2, 1},     {3, 1},     {3, 2},     {12, 0},     {4, 4}, 
        {13, 0},     {4, 4},     {14, 0},     {4, 4},     {15, 0}, 
        {4, 4}  };

  /** access to production table */
  public short[][] production_table() {return _production_table;}

  /** parse action table */
  protected static final short[][] _action_table = {
    /*0*/{0,-3,10,2,12,14,14,4,16,3,18,7,20,8,23,10,24,6,30,9,-1,0},
    /*1*/{10,2,11,-3,12,14,14,4,16,3,18,7,20,8,23,10,24,6,30,9,-1,0},
    /*2*/{10,-15,12,-15,14,-15,16,-15,17,-15,18,-15,20,-15,23,-15,24,-15,30,-15,-1,0},
    /*3*/{10,-13,12,-13,14,-13,15,-13,16,-13,18,-13,20,-13,23,-13,24,-13,30,-13,-1,0},
    /*4*/{0,-4,3,-4,5,-4,7,-4,9,-4,10,2,11,-4,12,14,13,-4,14,4,15,-4,16,3,17,-4,18,7,19,-4,20,8,21,-4,22,-4,23,10,24,6,30,9,31,-4,-1,0},
    /*5*/{0,-21,2,-21,3,-21,4,-21,5,-21,6,-21,7,-21,8,-21,9,-21,10,-21,11,-21,12,-21,13,-21,14,-21,15,-21,16,-21,17,-21,18,-21,19,-21,20,-21,21,-21,22,-21,23,-21,24,-21,30,-21,31,-21,-1,0},
    /*6*/{10,2,12,14,14,4,16,3,18,7,19,-3,20,8,23,10,24,6,30,9,-1,0},
    /*7*/{10,2,12,14,14,4,16,3,18,7,20,8,21,-3,23,10,24,6,30,9,-1,0},
    /*8*/{10,2,12,14,14,4,16,3,18,7,20,8,23,10,24,6,30,9,31,-3,-1,0},
    /*9*/{10,-18,12,-18,14,-18,16,-18,18,-18,20,-18,22,-18,23,-18,24,-18,30,-18,-1,0},
    /*10*/{0,-1,3,-1,5,-1,7,-1,9,-1,11,-1,13,-1,15,-1,17,-1,19,-1,21,-1,22,-1,31,-1,-1,0},
    /*11*/{0,-5,3,-5,5,-5,7,-5,9,-5,10,-5,11,-5,12,-5,13,-5,14,-5,15,-5,16,-5,17,-5,18,-5,19,-5,20,-5,21,-5,22,-5,23,-5,24,-5,30,-5,31,-5,-1,0},
    /*12*/{0,38,-1,0},
    /*13*/{10,-11,12,-11,13,-11,14,-11,16,-11,18,-11,20,-11,23,-11,24,-11,30,-11,-1,0},
    /*14*/{0,-7,2,20,3,-7,4,18,5,-7,6,17,7,-7,8,21,9,-7,10,-7,11,-7,12,-7,13,-7,14,-7,15,-7,16,-7,17,-7,18,-7,19,-7,20,-7,21,-7,22,-7,23,-7,24,-7,30,-7,31,-7,-1,0},
    /*15*/{0,-8,2,20,3,-8,4,18,5,-8,6,17,7,-8,8,21,9,-8,10,-8,11,-8,12,-8,13,-8,14,-8,15,-8,16,-8,17,-8,18,-8,19,-8,20,-8,21,-8,22,-8,23,-8,24,-8,30,-8,31,-8,-1,0},
    /*16*/{7,-28,10,-28,12,-28,14,-28,16,-28,18,-28,20,-28,23,-28,24,-28,30,-28,-1,0},
    /*17*/{5,-26,10,-26,12,-26,14,-26,16,-26,18,-26,20,-26,23,-26,24,-26,30,-26,-1,0},
    /*18*/{0,-22,2,-22,3,-22,4,-22,5,-22,6,-22,7,-22,8,-22,9,-22,10,-22,11,-22,12,-22,13,-22,14,-22,15,-22,16,-22,17,-22,18,-22,19,-22,20,-22,21,-22,22,-22,23,-22,24,-22,30,-22,31,-22,-1,0},
    /*19*/{3,-24,10,-24,12,-24,14,-24,16,-24,18,-24,20,-24,23,-24,24,-24,30,-24,-1,0},
    /*20*/{9,-30,10,-30,12,-30,14,-30,16,-30,18,-30,20,-30,23,-30,24,-30,30,-30,-1,0},
    /*21*/{9,-3,10,2,12,14,14,4,16,3,18,7,20,8,23,10,24,6,30,9,-1,0},
    /*22*/{9,24,-1,0},
    /*23*/{0,-31,2,-31,3,-31,4,-31,5,-31,6,-31,7,-31,8,-31,9,-31,10,-31,11,-31,12,-31,13,-31,14,-31,15,-31,16,-31,17,-31,18,-31,19,-31,20,-31,21,-31,22,-31,23,-31,24,-31,30,-31,31,-31,-1,0},
    /*24*/{3,-3,10,2,12,14,14,4,16,3,18,7,20,8,23,10,24,6,30,9,-1,0},
    /*25*/{3,27,-1,0},
    /*26*/{0,-25,2,-25,3,-25,4,-25,5,-25,6,-25,7,-25,8,-25,9,-25,10,-25,11,-25,12,-25,13,-25,14,-25,15,-25,16,-25,17,-25,18,-25,19,-25,20,-25,21,-25,22,-25,23,-25,24,-25,30,-25,31,-25,-1,0},
    /*27*/{5,-3,10,2,12,14,14,4,16,3,18,7,20,8,23,10,24,6,30,9,-1,0},
    /*28*/{5,30,-1,0},
    /*29*/{0,-27,2,-27,3,-27,4,-27,5,-27,6,-27,7,-27,8,-27,9,-27,10,-27,11,-27,12,-27,13,-27,14,-27,15,-27,16,-27,17,-27,18,-27,19,-27,20,-27,21,-27,22,-27,23,-27,24,-27,30,-27,31,-27,-1,0},
    /*30*/{7,-3,10,2,12,14,14,4,16,3,18,7,20,8,23,10,24,6,30,9,-1,0},
    /*31*/{7,33,-1,0},
    /*32*/{0,-29,2,-29,3,-29,4,-29,5,-29,6,-29,7,-29,8,-29,9,-29,10,-29,11,-29,12,-29,13,-29,14,-29,15,-29,16,-29,17,-29,18,-29,19,-29,20,-29,21,-29,22,-29,23,-29,24,-29,30,-29,31,-29,-1,0},
    /*33*/{0,-23,2,-23,3,-23,4,-23,5,-23,6,-23,7,-23,8,-23,9,-23,10,-23,11,-23,12,-23,13,-23,14,-23,15,-23,16,-23,17,-23,18,-23,19,-23,20,-23,21,-23,22,-23,23,-23,24,-23,30,-23,31,-23,-1,0},
    /*34*/{10,2,12,14,13,-3,14,4,16,3,18,7,20,8,23,10,24,6,30,9,-1,0},
    /*35*/{13,37,-1,0},
    /*36*/{0,-12,2,-12,3,-12,4,-12,5,-12,6,-12,7,-12,8,-12,9,-12,10,-12,11,-12,12,-12,13,-12,14,-12,15,-12,16,-12,17,-12,18,-12,19,-12,20,-12,21,-12,22,-12,23,-12,24,-12,30,-12,31,-12,-1,0},
    /*37*/{0,-2,-1,0},
    /*38*/{10,2,12,14,14,4,16,3,18,7,20,8,22,-3,23,10,24,6,30,9,-1,0},
    /*39*/{22,41,-1,0},
    /*40*/{0,-19,2,-19,3,-19,4,-19,5,-19,6,-19,7,-19,8,-19,9,-19,10,-19,11,-19,12,-19,13,-19,14,-19,15,-19,16,-19,17,-19,18,-19,19,-19,20,-19,21,-19,22,-19,23,-19,24,-19,30,-19,31,-19,-1,0},
    /*41*/{31,43,-1,0},
    /*42*/{0,-10,2,-10,3,-10,4,-10,5,-10,6,-10,7,-10,8,-10,9,-10,10,-10,11,-10,12,-10,13,-10,14,-10,15,-10,16,-10,17,-10,18,-10,19,-10,20,-10,21,-10,22,-10,23,-10,24,-10,30,-10,31,-10,-1,0},
    /*43*/{21,45,-1,0},
    /*44*/{0,-17,2,-17,3,-17,4,-17,5,-17,6,-17,7,-17,8,-17,9,-17,10,-17,11,-17,12,-17,13,-17,14,-17,15,-17,16,-17,17,-17,18,-17,19,-17,20,-17,21,-17,22,-17,23,-17,24,-17,30,-17,31,-17,-1,0},
    /*45*/{19,47,-1,0},
    /*46*/{0,-20,2,-20,3,-20,4,-20,5,-20,6,-20,7,-20,8,-20,9,-20,10,-20,11,-20,12,-20,13,-20,14,-20,15,-20,16,-20,17,-20,18,-20,19,-20,20,-20,21,-20,22,-20,23,-20,24,-20,30,-20,31,-20,-1,0},
    /*47*/{0,-6,3,-6,5,-6,7,-6,9,-6,10,-6,11,-6,12,-6,13,-6,14,-6,15,-6,16,-6,17,-6,18,-6,19,-6,20,-6,21,-6,22,-6,23,-6,24,-6,30,-6,31,-6,-1,0},
    /*48*/{10,2,12,14,14,4,15,-3,16,3,18,7,20,8,23,10,24,6,30,9,-1,0},
    /*49*/{15,51,-1,0},
    /*50*/{0,-14,2,-14,3,-14,4,-14,5,-14,6,-14,7,-14,8,-14,9,-14,10,-14,11,-14,12,-14,13,-14,14,-14,15,-14,16,-14,17,-14,18,-14,19,-14,20,-14,21,-14,22,-14,23,-14,24,-14,30,-14,31,-14,-1,0},
    /*51*/{10,2,12,14,14,4,16,3,17,-3,18,7,20,8,23,10,24,6,30,9,-1,0},
    /*52*/{17,54,-1,0},
    /*53*/{0,-16,2,-16,3,-16,4,-16,5,-16,6,-16,7,-16,8,-16,9,-16,10,-16,11,-16,12,-16,13,-16,14,-16,15,-16,16,-16,17,-16,18,-16,19,-16,20,-16,21,-16,22,-16,23,-16,24,-16,30,-16,31,-16,-1,0},
    /*54*/{11,56,-1,0},
    /*55*/{0,-9,2,-9,3,-9,4,-9,5,-9,6,-9,7,-9,8,-9,9,-9,10,-9,11,-9,12,-9,13,-9,14,-9,15,-9,16,-9,17,-9,18,-9,19,-9,20,-9,21,-9,22,-9,23,-9,24,-9,30,-9,31,-9,-1,0},
  };

  /** access to parse action table */
  public short[][] action_table() {return _action_table;}

  /** reduce_goto table */
  protected static final short[][] _reduce_table = {
    /*0*/{1,12,2,14,5,10,6,11,7,4,-1,-1},
    /*1*/{1,54,2,14,5,10,6,11,7,4,-1,-1},
    /*2*/{10,51,-1,-1},
    /*3*/{9,48,-1,-1},
    /*4*/{2,14,6,47,-1,-1},
    /*5*/{-1,-1},
    /*6*/{1,45,2,14,5,10,6,11,7,4,-1,-1},
    /*7*/{1,43,2,14,5,10,6,11,7,4,-1,-1},
    /*8*/{1,41,2,14,5,10,6,11,7,4,-1,-1},
    /*9*/{11,38,-1,-1},
    /*10*/{-1,-1},
    /*11*/{-1,-1},
    /*12*/{-1,-1},
    /*13*/{8,34,-1,-1},
    /*14*/{3,15,4,18,-1,-1},
    /*15*/{4,33,-1,-1},
    /*16*/{14,30,-1,-1},
    /*17*/{13,27,-1,-1},
    /*18*/{-1,-1},
    /*19*/{12,24,-1,-1},
    /*20*/{15,21,-1,-1},
    /*21*/{1,22,2,14,5,10,6,11,7,4,-1,-1},
    /*22*/{-1,-1},
    /*23*/{-1,-1},
    /*24*/{1,25,2,14,5,10,6,11,7,4,-1,-1},
    /*25*/{-1,-1},
    /*26*/{-1,-1},
    /*27*/{1,28,2,14,5,10,6,11,7,4,-1,-1},
    /*28*/{-1,-1},
    /*29*/{-1,-1},
    /*30*/{1,31,2,14,5,10,6,11,7,4,-1,-1},
    /*31*/{-1,-1},
    /*32*/{-1,-1},
    /*33*/{-1,-1},
    /*34*/{1,35,2,14,5,10,6,11,7,4,-1,-1},
    /*35*/{-1,-1},
    /*36*/{-1,-1},
    /*37*/{-1,-1},
    /*38*/{1,39,2,14,5,10,6,11,7,4,-1,-1},
    /*39*/{-1,-1},
    /*40*/{-1,-1},
    /*41*/{-1,-1},
    /*42*/{-1,-1},
    /*43*/{-1,-1},
    /*44*/{-1,-1},
    /*45*/{-1,-1},
    /*46*/{-1,-1},
    /*47*/{-1,-1},
    /*48*/{1,49,2,14,5,10,6,11,7,4,-1,-1},
    /*49*/{-1,-1},
    /*50*/{-1,-1},
    /*51*/{1,52,2,14,5,10,6,11,7,4,-1,-1},
    /*52*/{-1,-1},
    /*53*/{-1,-1},
    /*54*/{-1,-1},
    /*55*/{-1,-1},
  };

  /** access to reduce_goto table */
  public short[][] reduce_table() {return _reduce_table;}

  /** instance of action encapsulation class */
  protected CUP$SEparser$actions action_obj;

  /** action encapsulation object initializer */
  protected void init_actions()
    {
      action_obj = new CUP$SEparser$actions();
    }

  /** invoke a user supplied parse action */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$SEparser$do_action(act_num, parser, stack, top);
  }

  /** start state */
  public int start_state() {return 0;}
  /** start production */
  public int start_production() {return 1;}

  /** EOF Symbol index */
  public int EOF_sym() {return 0;}

  /** error Symbol index */
  public int error_sym() {return 1;}


  /** user initialization */
  public void user_init() throws java.lang.Exception
    {
 action_obj.initActions( IFont , ICol , IMode ); 
    }

  /** scan to get the next Symbol */
  public java_cup.runtime.Symbol scan()
    throws java.lang.Exception
    {
 return( ThisSLexAnal.scanSymbol( ) ); 
    }

 


protected static int IMode = 0;
protected static Integer ICol = null;
protected static Paint IFont = null;
protected static SLexeme CrsrLex = null;
protected static RectF CrsrRect = null;


public final void parseAll( FlexString Instr , HighLevelBinTree ParseTree , 
			int MyMode , Paint InFont , Integer col )
			throws MathImageParseException
			
/*
Fun: Given an expression, generates its parse tree.
In: Character string Instr to be parsed.
Out: Parse tree.  Returns true iff. there is an error.
Pre: None.
Post: Parse tree is returned in ParseTree.  If there's an error, the parse tree is
	empty.
Programmed By: Thorn Green.
*/

	{
	SLexAnal MyLex = /* MySLexAnal; */ getSLexAnal( Instr );

	ICol = col;
	IFont = InFont;
	IMode = MyMode;
	
	Symbol MySym = null;

	try{
	MySym = parse();
	} catch( Exception e ) { action_obj.finalizeActions(); 
				throw( new MathImageParseException( e ) ); }

	CrsrLex = action_obj.getCrsrLex();
	CrsrRect = action_obj.getCrsrRect();
	action_obj.chkFinalActions();

	HighLevelBinTree MyTree = (HighLevelBinTree)( MySym.value );
	MyTree.copyDataPlusPtrInfo( ParseTree );
	};
	
	
		public final void clear( )
		
/*
Fun: Releases all memory allocated by the analyzer.
In: None.
Out: None.
Pre: None.
Post: All nodes allocated by this class will be cleared.
Programmed By: Thorn Green.
*/

	{
	/* SLexAnal MyLex = MySLexAnal;
	MyLex.clear();
	MyList.eraseAllInfo(); */
	};
	
		public final int getErrCode( )
			{ return( ErrCode ); };

public RectF getCrsrRect( )
	{ return( CrsrRect ); }

public SLexeme getCrsrLex( )
	{ return( CrsrLex ); }

private final static SLexAnal getSLexAnal( FlexString in )
			{
			if( ThisSLexAnal == null )
				{
				ThisSLexAnal = new SLexAnal( in );
				}
				else
				{
				ThisSLexAnal.resetLexer( in );
				}

			return( ThisSLexAnal );
			}

static SLexAnal ThisSLexAnal = null;
private int ErrCode;


}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$SEparser$actions {




	//$$strtCprt
	/**
	* Vector Victor -- Graphing Calculator Program For Android
	* 
	* Copyright (C) 1993-2013 Thornton Green
	* 
	* This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as
	* published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.
	* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty 
	* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
	* You should have received a copy of the GNU General Public License along with this program; if not, 
	* see <http://www.gnu.org/licenses>.
	* Additional permission under GNU GPL version 3 section 7
	*
	* If you modify this Program, or any covered work, by linking or combining it with Android 
	* (or a modified version of that library), containing parts covered by the terms of the Android licenses, 
	* the licensors of this Program grant you additional permission to convey the resulting work. {Corresponding Source for
	* a non-source form of such a combination shall include the source code for the parts of Android used as well 
	* as that of the covered work.}
	* 
	* If you modify this Program, or any covered work, by linking or combining it with Dexmaker 
	* (or a modified version of that library), containing parts covered by the terms of Apache License 2.0, 
	* the licensors of this Program grant you additional permission to convey the resulting work. {Corresponding Source for
	* a non-source form of such a combination shall include the source code for the parts of Dexmaker used as well 
	* as that of the covered work.}
	* 
	* If you modify this Program, or any covered work, by linking or combining it with JLex 
	* (or a modified version of that library), containing parts covered by the terms of JLex license listed below, 
	* the licensors of this Program grant you additional permission to convey the resulting work. {Corresponding Source for
	* a non-source form of such a combination shall include the source code for the parts of JLex used as well 
	* as that of the covered work.}
	* 
	* If you modify this Program, or any covered work, by linking or combining it with Java CUP 
	* (or a modified version of that library), containing parts covered by the terms of Java CUP license listed below, 
	* the licensors of this Program grant you additional permission to convey the resulting work. {Corresponding Source for
	* a non-source form of such a combination shall include the source code for the parts of Java CUP used as well 
	* as that of the covered work.}
	* 
	* If you modify this Program, or any covered work, by linking or combining it with TwoDScrollView 
	* (or a modified version of that library), containing parts covered by the terms of Apache License 2.0, 
	* the licensors of this Program grant you additional permission to convey the resulting work. {Corresponding Source for
	* a non-source form of such a combination shall include the source code for the parts of TwoDScrollView used as well 
	* as that of the covered work.}
	*
	*
	* Android is available at http://android.com
	*
	* Dexmaker is available at https://code.google.com/p/dexmaker/
	*
	* JLex is available at http://freecode.com/projects/jlex
	* 
	* Java CUP is available at http://www2.cs.turn.edu/projects/cup/
	* 
	* TwoDScrollView is available at http://blog.gorges.us/2010/06/android-two-dimensional-scrollview/
	*
	*
	* The licenses for Java CUP and JLex are listed below:
	* 
	* ****************************************************************************
	*
	* JLex COPYRIGHT NOTICE, LICENSE AND DISCLAIMER. 
	*
	* Copyright 1996 by Elliot Joel Berk. 
	*
	* Permission to use, copy, modify, and distribute this software and its documentation for any 
	* purpose and without fee is hereby granted, provided that the above copyright notice appear 
	* in all copies and that both the copyright notice and this permission notice and warranty 
	* disclaimer appear in supporting documentation, and that the name of Elliot Joel Berk not be 
	* used in advertising or publicity pertaining to distribution of the software without specific, 
	* written prior permission. 
	*
	* Elliot Joel Berk disclaims all warranties with regard to this software, including all implied 
	* warranties of merchantability and fitness. In no event shall Elliot Joel Berk be liable for 
	* any special, indirect or consequential damages or any damages whatsoever resulting from loss 
	* of use, data or profits, whether in an action of contract, negligence or other tortious 
	* action, arising out of or in connection with the use or performance of this software. 
	* 
	* ********************************************************************************
	*
	* CUP Parser Generator Copyright Notice, License, and Disclaimer
	* 
	* Copyright 1996-1999 by Scott Hudson, Frank Flannery, C. Scott Ananian 
	* 
	* Permission to use, copy, modify, and distribute this software and its documentation for any 
	* purpose and without fee is hereby granted, provided that the above copyright notice appear 
	* in all copies and that both the copyright notice and this permission notice and warranty 
	* disclaimer appear in supporting documentation, and that the names of the authors or their 
	* employers not be used in advertising or publicity pertaining to distribution of the software 
	* without specific, written prior permission. 
	* 
	* The authors and their employers disclaim all warranties with regard to this software, 
	* including all implied warranties of merchantability and fitness. In no event shall the 
	* authors or their employers be liable for any special, indirect or consequential damages or 
	* any damages whatsoever resulting from loss of use, data or profits, whether in an action of 
	* contract, negligence or other tortious action, arising out of or in connection with the use 
	* or performance of this software.
	*
	* ******************************************************************************
	*
	*
	*/
	//$$endCprt



/**
*
* --- SOURCE MODIFICATION LIST ---
*
* Please document all changes to this source file here.
* Feel free to add rows if needed.
*
*
*    |-----------------------|-------------------------------------------------|----------------------------------------------------------------------|---------------------------------------------------------------...
*    | Date of Modification  |    Author of Modification                       |    Reason for Modification                                           |    Description of Modification (use multiple rows if needed)  ... 
*    |-----------------------|-------------------------------------------------|----------------------------------------------------------------------|---------------------------------------------------------------...
*    |                       |                                                 |                                                                      |
*    | 9/24/2000             | Thorn Green (viridian_1138@yahoo.com)           | Needed to provide a standard way to document source file changes.    | Added a souce modification list to the documentation so that changes to the souce could be recorded. 
*    | 10/22/2000            | Thorn Green (viridian_1138@yahoo.com)           | Methods did not have names that followed standard Java conventions.  | Performed a global modification to bring the names within spec.
*    | 10/29/2000            | Thorn Green (viridian_1138@yahoo.com)           | Classes did not have names that followed standard Java conventions.  | Performed a global modification to bring the names within spec.
*    | 12/30/2001            | Thorn Green (viridian_1138@yahoo.com)           | Expand handling of MathImage parse errors.                           | Created and propagated MathImageParseException.
*    | 08/07/2004            | Thorn Green (viridian_1138@yahoo.com)           | Establish baseline for all changes in the last year.                 | Establish baseline for all changes in the last year.
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*    |                       |                                                 |                                                                      |
*
*
*/




protected int TempMode = 0;
protected RectF CrsrRect = null;
protected SLexeme CrsrLex = null;


protected HighLevelBinTree finalMergeExpr( HighLevelBinTree e1 )
	{
	if( !( e1.empty() ) )
		{
		SLexeme MyLex = (SLexeme)( e1.getNode() );

		if( MyLex.getMyMatch() == SEval.LinearLayout )
			{
			HighLevelBinTree TTree = new HighLevelBinTree();
			e1.copyDataPlusPtrInfo( TTree );
			TTree.left();
			double ConX = 0;
			double ConY = 0;
			double ImgX = 0;
			double ImgY = 0;
			double ConWidth = 0;
			double ConYMax = 0;
			double ImgWidth = 0;
			double ImgYMax = 0;

			double CurConYMax = 0;
			double CurImgYMax = 0;

			SLexeme ThisLex = (SLexeme)( TTree.getNode() );
			ImgX = ThisLex.getImgRect().left;
			ImgWidth = -ImgX;

			while( !( TTree.rThread() ) )
				{
				ThisLex = (SLexeme)( TTree.getNode() );
				ThisLex.setXOffset( ConWidth );
				ConWidth += ThisLex.getConnRect().width();

				if( ThisLex.getConnRect().top < ConY ) ConY = ThisLex.getConnRect().top;
				if( ThisLex.getImgRect().top < ImgY ) ImgY = ThisLex.getImgRect().top;

				CurConYMax = ThisLex.getConnRect().top + ThisLex.getConnRect().height();
				CurImgYMax = ThisLex.getImgRect().top + ThisLex.getImgRect().height();
				if( CurConYMax > ConYMax ) ConYMax = CurConYMax;
				if( CurImgYMax > ImgYMax ) ImgYMax = CurImgYMax;

				TTree.right();
				}

			ImgWidth += ConWidth;
			ThisLex = (SLexeme)( TTree.getNode() );
			ThisLex.setXOffset( ConWidth );
			ConWidth += ThisLex.getConnRect().width();
			ImgWidth += ThisLex.getImgRect().width() + ThisLex.getImgRect().left;

			if( ThisLex.getConnRect().top < ConY ) ConY = ThisLex.getConnRect().top;
			if( ThisLex.getImgRect().top < ImgY ) ImgY = ThisLex.getImgRect().top;

			CurConYMax = ThisLex.getConnRect().top + ThisLex.getConnRect().height();
			CurImgYMax = ThisLex.getImgRect().top + ThisLex.getImgRect().height();
			if( CurConYMax > ConYMax ) ConYMax = CurConYMax;
			if( CurImgYMax > ImgYMax ) ImgYMax = CurImgYMax;

			MyLex.setConnRect( new RectF( (float)( ConX ) , (float)( ConY ) , (float)( ConX + ConWidth ) , (float)( ConYMax ) ) );
			MyLex.setImgRect( new RectF( (float)( ImgX ) , (float)( ImgY ) , (float)( ImgX + ImgWidth ) , (float)( ImgYMax ) ) );
			}
		}

	return( e1 );
	}


protected HighLevelBinTree mergeExpr( HighLevelBinTree e1 , HighLevelBinTree e2 )
	{
	if( e2.empty() )
		{
		return( e1 );
		}

	if( e1.empty() )
		{
		return( e2 );
		}

	HighLevelBinTree MyTree = null;
	SLexeme InLex = (SLexeme)( e1.getNode() );

	if( InLex.getMyMatch() == SEval.LinearLayout )
		{
		MyTree = e1;
		HighLevelBinTree OpTree = new HighLevelBinTree();
		MyTree.copyDataPlusPtrInfo( OpTree );
		OpTree.left();

		while( !( OpTree.rThread() ) )
			OpTree.right();

		e2.connectRight( OpTree );
		}
		else
		{
		MyTree = new HighLevelBinTree();
		HighLevelBinTree OpTree = new HighLevelBinTree();
		SLexeme MyLex = new SLexeme();
		MyLex.setMyMatch( SEval.LinearLayout );
		MyTree.addRight( MyLex );
		MyTree.setCopyMode( Meta.COPY_DO_NOTHING );
		MyTree.setEraseMode( Meta.WAKE );
		e1.connectLeft( MyTree );
		MyTree.copyDataPlusPtrInfo( OpTree );
		OpTree.left();
		e2.connectRight( OpTree );
		}

	return( MyTree );
	}


	private SLexeme simpLexeme( )

		{
		SLexeme MyLex = new SLexeme();
		MyLex.setConnRect( new RectF( 0 , 0 , 0 , 0 ) );
		MyLex.setImgRect( new RectF( 0 , 0 , 0 , 0 ) );
		return( MyLex );
		}


	private RectF buildConnRect( SLexeme[] in )

		{
		double x = 0;
		double y = 0;
		double maxX = 0;
		double maxY = 0;
		int max = in.length;
		int count;

		for( count = 0 ; count < max ; ++count )
			{
			SLexeme MyLex = in[ count ];
			double OffX = MyLex.getXOffset();
			double OffY = MyLex.getYOffset();

			if( ( MyLex.getConnRect().left + OffX ) < x ) x = MyLex.getConnRect().left + OffX;
			if( ( MyLex.getConnRect().top + OffY ) < y ) y = MyLex.getConnRect().top + OffY;

			double xw = MyLex.getConnRect().width() + MyLex.getConnRect().left + OffX;
			double yw = MyLex.getConnRect().height() + MyLex.getConnRect().top + OffY;

			if( xw > maxX ) maxX = xw;
			if( yw > maxY ) maxY = yw;
			}
		
		RectF MyRect = new RectF( (float) x , (float) y , (float) maxX , (float) maxY );
		return( MyRect );
		}


	private RectF buildImgRect( SLexeme[] in )

		{
		double x = 0;
		double y = 0;
		double maxX = 0;
		double maxY = 0;
		int max = in.length;
		int count;

		for( count = 0 ; count < max ; ++count )
			{
			SLexeme MyLex = in[ count ];
			double OffX = MyLex.getXOffset();
			double OffY = MyLex.getYOffset();

			if( ( MyLex.getImgRect().left + OffX ) < x ) x = MyLex.getImgRect().left + OffX;
			if( ( MyLex.getImgRect().top + OffY ) < y ) y = MyLex.getImgRect().top + OffY;

			double xw = MyLex.getImgRect().width() + MyLex.getImgRect().left + OffX;
			double yw = MyLex.getImgRect().height() + MyLex.getImgRect().top + OffY;

			if( xw > maxX ) maxX = xw;
			if( yw > maxY ) maxY = yw;
			}
		
		RectF MyRect = new RectF( (float) x , (float) y , (float) maxX , (float) maxY );
		return( MyRect );
		}


protected HighLevelBinTree mergeLexpr( HighLevelBinTree Tree1 , HighLevelBinTree Tree2 )
	{
	if( Tree2.empty() )
		return( Tree1 );

	Paint InFont = (Paint) FontStk.peek();
	Double size = (Double) DblStk.peek();

	if( Tree1.empty() )
		{
		SLexeme Tmp = simpLexeme();
		Paint NewPaint = new Paint( InFont );
		NewPaint.setColor( Color.BLACK );
		Tmp.setPaint( NewPaint );
		Tmp.setMetaPtr( new FlexString() );
		Tree1.addRight( Tmp );
		Tree1.setCopyMode( Meta.COPY_DO_NOTHING );
		Tree1.setEraseMode( Meta.WAKE );
		}


	HighLevelBinTree OutTree = new HighLevelBinTree();
	HighLevelBinTree TempTree = new HighLevelBinTree();
	SLexeme MyLex = new SLexeme();
	MyLex.setMyMatch( SEval.FormattedLayout );
	OutTree.addRight( MyLex );
	OutTree.setCopyMode( Meta.COPY_DO_NOTHING );
	OutTree.setEraseMode( Meta.WAKE );
	OutTree.copyDataPlusPtrInfo( TempTree );
	Tree1.connectLeft( TempTree );
	TempTree.left();
	Tree2.connectRight( TempTree );


	SLexeme ScriptLex = null;
	SLexeme OverscriptLex = null;
	SLexeme UnderscriptLex = null;
	SLexeme SuperscriptLex = null;
	SLexeme SubscriptLex = null;

	HighLevelBinTree TTree = new HighLevelBinTree();
	OutTree.copyDataPlusPtrInfo( TTree );
	TTree.left();

	SLexeme ThisLex = (SLexeme)( TTree.getNode() );
	ScriptLex = ThisLex;

	while( !( TTree.rThread() ) )
		{
		TTree.right();

		ThisLex = (SLexeme)( TTree.getNode() );
					
		switch( ThisLex.getMyMatch() )
			{
			case SEval.BeginSub:
				SubscriptLex = ThisLex;
				break;

			case SEval.BeginSup:
				SuperscriptLex = ThisLex;
				break;

			case SEval.BeginAbove:
				OverscriptLex = ThisLex;
				break;

			case SEval.BeginBelow:
				UnderscriptLex = ThisLex;
				break;

			}

		}

	if( SuperscriptLex == null ) SuperscriptLex = simpLexeme();
	if( SubscriptLex == null ) SubscriptLex = simpLexeme();
	if( OverscriptLex == null ) OverscriptLex = simpLexeme();
	if( UnderscriptLex == null ) UnderscriptLex = simpLexeme();

	Paint SFont = smlFont( InFont , size );
	double leading = 0.0;
	if( ( TempMode & MathImageConstants.ParseOnlyMode ) == 0 )
		{
		Paint pn = new Paint();
		// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		leading = pn.getFontMetrics().leading;
		}

	double ScriptXOff = 0;
	double ScriptYOff = 0;
	double UnderscriptXOff = 0;
	double UnderscriptYOff = 0;
	double OverscriptXOff = 0;
	double OverscriptYOff = 0;
	double SuperscriptXOff = 0;
	double SuperscriptYOff = 0;
	double SubscriptXOff = 0;
	double SubscriptYOff = 0;

	double minOverYDelta = leading;
	/* minOverYDelta = 1; */

	OverscriptYOff = ScriptLex.getConnRect().top - minOverYDelta - 
		( OverscriptLex.getConnRect().height() + OverscriptLex.getConnRect().top );


	minOverYDelta = leading;
	/* minOverYDelta = 1; */

	SuperscriptYOff = OverscriptYOff + OverscriptLex.getConnRect().top - minOverYDelta - 
		( SuperscriptLex.getConnRect().height() + SuperscriptLex.getConnRect().top );



	double minUnderYDelta = leading;
	/* minUnderYDelta = 1; */

	UnderscriptYOff = minUnderYDelta - UnderscriptLex.getConnRect().top +
		( ScriptLex.getConnRect().height() + ScriptLex.getConnRect().top );

	minUnderYDelta = leading;
	/* minUnderYDelta = 1; */

	SubscriptYOff = UnderscriptYOff + minUnderYDelta - SubscriptLex.getConnRect().top +
		( UnderscriptLex.getConnRect().height() + UnderscriptLex.getConnRect().top );

	double ScriptCWidth = ( ScriptLex.getConnRect().width() + ScriptLex.getConnRect().left ) / 2;
	double OverscriptCWidth = ( OverscriptLex.getConnRect().width() + OverscriptLex.getConnRect().left ) / 2;
	double UnderscriptCWidth = ( UnderscriptLex.getConnRect().width() + UnderscriptLex.getConnRect().left ) / 2;

	double MaxCWidth = ScriptCWidth;
	if( OverscriptCWidth > MaxCWidth ) MaxCWidth = OverscriptCWidth;
	if( UnderscriptCWidth > MaxCWidth ) MaxCWidth = UnderscriptCWidth;

	ScriptXOff = MaxCWidth - ScriptCWidth;
	OverscriptXOff = MaxCWidth - OverscriptCWidth;
	UnderscriptXOff = MaxCWidth - UnderscriptCWidth;

	double ScriptXMax = ScriptLex.getConnRect().width() + ScriptXOff;
	double OverscriptXMax = OverscriptLex.getConnRect().width() + OverscriptXOff;
	double UnderscriptXMax = UnderscriptLex.getConnRect().width() + UnderscriptXOff;

	double MaxXMax = ScriptXMax;
	if( OverscriptXMax > MaxXMax ) MaxXMax = OverscriptXMax;
	if( UnderscriptXMax > MaxXMax ) MaxXMax = UnderscriptXMax;

	SuperscriptXOff = MaxXMax;
	SubscriptXOff = MaxXMax;

	ScriptLex.setXOffset( ScriptXOff );
	ScriptLex.setYOffset( ScriptYOff );
	UnderscriptLex.setXOffset( UnderscriptXOff );
	UnderscriptLex.setYOffset( UnderscriptYOff );
	OverscriptLex.setXOffset( OverscriptXOff );
	OverscriptLex.setYOffset( OverscriptYOff );
	SuperscriptLex.setXOffset( SuperscriptXOff );
	SuperscriptLex.setYOffset( SuperscriptYOff );
	SubscriptLex.setXOffset( SubscriptXOff );
	SubscriptLex.setYOffset( SubscriptYOff );
				
	SLexeme[] MyArr = { ScriptLex , SuperscriptLex , SubscriptLex , OverscriptLex , UnderscriptLex };
	MyLex.setConnRect( buildConnRect( MyArr ) );
	MyLex.setImgRect( buildImgRect( MyArr ) );

	return( OutTree );
	}


protected HighLevelBinTree mergeModifiers( HighLevelBinTree MyTree , HighLevelBinTree TempTree )
	{
	if( MyTree.empty() )
		{
		return( TempTree );
		}
		
	if( TempTree.empty() )
		{
		return( MyTree );
		}
		

	HighLevelBinTree OpTree = new HighLevelBinTree();
	MyTree.copyDataPlusPtrInfo( OpTree );
	
	while( !( OpTree.lThread() ) )
		OpTree.left();

	OpTree.left();

	TempTree.connectRight( OpTree );

	return( MyTree );
	}


protected HighLevelBinTree handleModifier( SLexeme TopLex , HighLevelBinTree TempTree )
	{
	HighLevelBinTree MyTree = new HighLevelBinTree();

	if( !( TempTree.empty() ) )
		{
		MyTree.addRight( TopLex );
		MyTree.setCopyMode( Meta.COPY_DO_NOTHING );
		MyTree.setEraseMode( Meta.WAKE );
		TempTree.connectLeft( MyTree );

		HighLevelBinTree TTree = new HighLevelBinTree();
		MyTree.copyDataPlusPtrInfo( TTree );
		TTree.left();
		SLexeme TmpLex = (SLexeme)( TTree.getNode() );
		TopLex.setConnRect( TmpLex.getConnRect() );
		TopLex.setImgRect( TmpLex.getImgRect() );
		}

	return( MyTree );
	}


protected HighLevelBinTree handleCursor( HighLevelBinTree in )
	{
	HighLevelBinTree e1 = in;
	HighLevelBinTree e2 = new HighLevelBinTree();

	SLexeme TempLex = new SLexeme();
	Paint InFont = (Paint) FontStk.peek();
	Paint OutFont = new Paint( InFont );
	OutFont.setColor( (Integer)( ColorStk.peek() ) );
	TempLex.setPaint( OutFont );
	TempLex.setMetaPtr( new FlexString() );

	double ascent = 0.0;
	if( ( TempMode & MathImageConstants.ParseOnlyMode ) == 0 )
		{
		Path path = new Path();
		OutFont.getTextPath( "X" , 0 , 1 , 0.0f , 0.0f , path );
		RectF bounds = new RectF();
		path.computeBounds(bounds, true);
		ascent = Math.max( Math.abs( bounds.top )  ,  Math.abs( bounds.bottom ) );
		}

	RectF ConnRect = new RectF( 0 , (float)( -ascent ) , 0 , (float)( ascent ) );	
	RectF ImgRect = new RectF( 0 , (float)( -ascent ) , 0 , (float)( ascent ) );
	TempLex.setConnRect( ConnRect );
	TempLex.setImgRect( ImgRect );

	CrsrLex = TempLex;

	e2.addRight( TempLex );
	e2.setCopyMode( Meta.COPY_DO_NOTHING );
	e2.setEraseMode( Meta.WAKE );
	HighLevelBinTree e3 = mergeExpr( e1 , e2 );
	HighLevelBinTree res = finalMergeExpr( e3 );

	SLexeme MyLex = (SLexeme)( res.getNode() );
	CrsrRect = MyLex.getConnRect();

	return( res );
	}


protected HighLevelBinTree handleHat( SLexeme e1 , HighLevelBinTree e2 )
	{ /* Future... */ return( e2 ); }


protected HighLevelBinTree handleTerm( SLexeme ThisLex )
	{
	Paint InFont = (Paint) FontStk.peek();
	Double size = (Double) DblStk.peek();

	HighLevelBinTree MyTree = new HighLevelBinTree();

	Paint OutFont = new Paint( InFont );
	OutFont.setColor( (Integer)( ColorStk.peek() ) );
	ThisLex.setPaint( OutFont );
	
	MyTree.addRight( ThisLex );
	MyTree.setCopyMode( Meta.COPY_DO_NOTHING );
	MyTree.setEraseMode( Meta.WAKE );

	if( ( TempMode & MathImageConstants.ParseOnlyMode ) == 0 )
		{
		FlexString mys = (FlexString)( ThisLex.getMetaPtr() );
		String str = mys.exportString();
		
		Path path = new Path();
		OutFont.getTextPath( str , 0 , str.length() , 0.0f , 0.0f , path );
		RectF bounds = new RectF();
		path.computeBounds(bounds, true);
		
		double cwidth = OutFont.measureText( str );
		
		double ImgX = bounds.left;
		double ImgY = bounds.top;
		double ImgWidth = bounds.width();
		double ImgHeight = bounds.height();
		
		RectF ConnRect = new RectF( (float) 0 , (float) ImgY , (float)( cwidth + 0 ) , (float)( ImgHeight + ImgY ) );

		RectF ImgRect = new RectF( (float) ImgX , (float) ImgY , (float)( ImgWidth + ImgX ) , (float)( ImgHeight + ImgY ) );

		ThisLex.setConnRect( ConnRect );
		ThisLex.setImgRect( ImgRect );
		}
		else
		{
		ThisLex.setConnRect( new RectF( 0 , 0 , 5 , 5 ) );
		ThisLex.setImgRect( new RectF( 0 , 0 , 5 , 5 ) );
		}
		
	return( MyTree );
	}


protected static final Stack DblStk = new Stack();
protected static final Stack FontStk = new Stack();
protected static final Stack ColorStk = new Stack();


protected void stackPop( )
	{
	DblStk.pop();
	FontStk.pop();
	}


protected void stackPushBold( )
	{
	DblStk.push( DblStk.peek() );
	Paint InFont = (Paint)( FontStk.peek() );
	Paint OutFont = new Paint( InFont );
	OutFont.setTypeface( Typeface.create( InFont.getTypeface() , Typeface.BOLD_ITALIC ) );
	FontStk.push( OutFont );
	}


protected void stackPushUp( )
	{
	DblStk.push( DblStk.peek() );
	Paint InFont = (Paint)( FontStk.peek() );
	Paint OutFont = new Paint( InFont );
	OutFont.setTypeface( Typeface.create( InFont.getTypeface() , Typeface.NORMAL ) );
	FontStk.push( OutFont );
	}


protected void stackPushBoldUp( )
	{
	DblStk.push( DblStk.peek() );
	Paint InFont = (Paint)( FontStk.peek() );
	Paint OutFont = new Paint( InFont );
	OutFont.setTypeface( Typeface.create( InFont.getTypeface() , Typeface.BOLD ) );
	FontStk.push( OutFont );
	}


protected Paint smlFont( Paint InFont , Double NSize )	
	{
	Paint MyFont = new Paint( InFont );
	MyFont.setTextSize( NSize.floatValue() );
	return( MyFont );
	}


protected void stackPushAbove( )
	{
	Double InDbl = (Double)( DblStk.peek() );
	Double OutDbl = new Double( InDbl.doubleValue() * 10.0 / 12.0 );
	DblStk.push( OutDbl );
	Paint InFont = (Paint)( FontStk.peek() );
	Paint OutFont = smlFont( InFont , OutDbl );
	FontStk.push( OutFont );
	}


protected void stackPushBelow( )
	{
	Double InDbl = (Double)( DblStk.peek() );
	Double OutDbl = new Double( InDbl.doubleValue() * 10.0 / 12.0 );
	DblStk.push( OutDbl );
	Paint InFont = (Paint)( FontStk.peek() );
	Paint OutFont = smlFont( InFont , OutDbl );
	FontStk.push( OutFont );
	}


protected void stackPushSup( )
	{
	Double InDbl = (Double)( DblStk.peek() );
	Double OutDbl = new Double( InDbl.doubleValue() * 10.0 / 12.0 );
	DblStk.push( OutDbl );
	Paint InFont = (Paint)( FontStk.peek() );
	Paint OutFont = smlFont( InFont , OutDbl );
	FontStk.push( OutFont );
	}


protected void stackPushSub( )
	{
	Double InDbl = (Double)( DblStk.peek() );
	Double OutDbl = new Double( InDbl.doubleValue() * 10.0 / 12.0 );
	DblStk.push( OutDbl );
	Paint InFont = (Paint)( FontStk.peek() );
	Paint OutFont = smlFont( InFont , OutDbl );
	FontStk.push( OutFont );
	}


protected void colorStackPush( SLexeme e1 )
	{
	ColorStk.push( new Integer( e1.getPaintNonNull().getColor() ) );
	}


protected void colorStackPop( )
	{
	ColorStk.pop();
	}

public RectF getCrsrRect( )
	{ return( CrsrRect ); }

public SLexeme getCrsrLex( )
	{ return( CrsrLex ); }

public void initActions( Paint InFont , Integer col , int MyMode )
	{
	TempMode = MyMode;
	CrsrLex = null;
	CrsrRect = null;
	Double MyDbl = new Double( InFont.getTextSize() );
	FontStk.ensureCapacity( 15 );
	DblStk.ensureCapacity( 15 );
	ColorStk.ensureCapacity( 15 );
	FontStk.push( InFont );
	DblStk.push( MyDbl );
	ColorStk.push( col );
	}


public void finalizeActions( )
	{
	while( !( FontStk.empty() ) )
		{
		FontStk.pop();
		}

	while( !( DblStk.empty() ) )
		{
		DblStk.pop();
		}

	while( !( ColorStk.empty() ) )
		{
		ColorStk.pop();
		}

	}


public void chkFinalActions( )
	{
	FontStk.pop();
	DblStk.pop();
	ColorStk.pop();

	if( !( FontStk.empty() ) )
		{ finalizeActions(); throw( new RuntimeException( "Font Stack Not Empty." ) ); }

	if( !( DblStk.empty() ) )
		{ finalizeActions(); throw( new RuntimeException( "Dbl Stack Not Empty." ) ); }

	if( !( ColorStk.empty() ) )
		{ finalizeActions(); throw( new RuntimeException( "Color Stack Not Empty." ) ); }

	}


 

  /** Constructor */
  CUP$SEparser$actions() { }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$SEparser$do_action(
    int                        CUP$SEparser$act_num,
    java_cup.runtime.lr_parser CUP$SEparser$parser,
    java.util.Stack            CUP$SEparser$stack,
    int                        CUP$SEparser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$SEparser$result;

      /* select the action based on the action number */
      switch (CUP$SEparser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // MODIFIER ::= BeginSub NT$7 LINE EndSub 
            {
              HighLevelBinTree RESULT = null;
              // propagate RESULT from NT$7
              if ( ((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-2)).value != null )
                RESULT = (HighLevelBinTree) ((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-2)).value;
		int e1left = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-3)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-3)).right;
		SLexeme e1 = (SLexeme)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-3)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).right;
		HighLevelBinTree e2 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).value;
		 stackPop(); RESULT = handleModifier( e1 , e2 ); 
              CUP$SEparser$result = new java_cup.runtime.Symbol(4/*MODIFIER*/, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-3)).left, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, RESULT);
            }
          return CUP$SEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // NT$7 ::= 
            {
              Object RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right;
		SLexeme e1 = (SLexeme)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).value;
 stackPushSub(); 
              CUP$SEparser$result = new java_cup.runtime.Symbol(15/*NT$7*/, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, RESULT);
            }
          return CUP$SEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // MODIFIER ::= BeginSup NT$6 LINE EndSup 
            {
              HighLevelBinTree RESULT = null;
              // propagate RESULT from NT$6
              if ( ((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-2)).value != null )
                RESULT = (HighLevelBinTree) ((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-2)).value;
		int e1left = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-3)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-3)).right;
		SLexeme e1 = (SLexeme)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-3)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).right;
		HighLevelBinTree e2 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).value;
		 stackPop(); RESULT = handleModifier( e1 , e2 ); 
              CUP$SEparser$result = new java_cup.runtime.Symbol(4/*MODIFIER*/, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-3)).left, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, RESULT);
            }
          return CUP$SEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // NT$6 ::= 
            {
              Object RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right;
		SLexeme e1 = (SLexeme)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).value;
 stackPushSup(); 
              CUP$SEparser$result = new java_cup.runtime.Symbol(14/*NT$6*/, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, RESULT);
            }
          return CUP$SEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // MODIFIER ::= BeginBelow NT$5 LINE EndBelow 
            {
              HighLevelBinTree RESULT = null;
              // propagate RESULT from NT$5
              if ( ((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-2)).value != null )
                RESULT = (HighLevelBinTree) ((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-2)).value;
		int e1left = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-3)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-3)).right;
		SLexeme e1 = (SLexeme)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-3)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).right;
		HighLevelBinTree e2 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).value;
		 stackPop(); RESULT = handleModifier( e1 , e2 ); 
              CUP$SEparser$result = new java_cup.runtime.Symbol(4/*MODIFIER*/, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-3)).left, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, RESULT);
            }
          return CUP$SEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // NT$5 ::= 
            {
              Object RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right;
		SLexeme e1 = (SLexeme)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).value;
 stackPushBelow(); 
              CUP$SEparser$result = new java_cup.runtime.Symbol(13/*NT$5*/, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, RESULT);
            }
          return CUP$SEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // MODIFIER ::= BeginAbove NT$4 LINE EndAbove 
            {
              HighLevelBinTree RESULT = null;
              // propagate RESULT from NT$4
              if ( ((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-2)).value != null )
                RESULT = (HighLevelBinTree) ((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-2)).value;
		int e1left = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-3)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-3)).right;
		SLexeme e1 = (SLexeme)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-3)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).right;
		HighLevelBinTree e2 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).value;
		 stackPop(); RESULT = handleModifier( e1 , e2 ); 
              CUP$SEparser$result = new java_cup.runtime.Symbol(4/*MODIFIER*/, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-3)).left, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, RESULT);
            }
          return CUP$SEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // NT$4 ::= 
            {
              Object RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right;
		SLexeme e1 = (SLexeme)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).value;
 stackPushAbove(); 
              CUP$SEparser$result = new java_cup.runtime.Symbol(12/*NT$4*/, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, RESULT);
            }
          return CUP$SEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // MODIFIER_LIST ::= MODIFIER_LIST MODIFIER 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).right;
		HighLevelBinTree e1 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right;
		HighLevelBinTree e2 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).value;
		 RESULT = mergeModifiers( e1 , e2 ); 
              CUP$SEparser$result = new java_cup.runtime.Symbol(3/*MODIFIER_LIST*/, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, RESULT);
            }
          return CUP$SEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // MODIFIER_LIST ::= MODIFIER 
            {
              HighLevelBinTree RESULT = null;
		int eleft = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right;
		HighLevelBinTree e = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).value;
		 RESULT = e; 
              CUP$SEparser$result = new java_cup.runtime.Symbol(3/*MODIFIER_LIST*/, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, RESULT);
            }
          return CUP$SEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // S_EXPR ::= term 
            {
              HighLevelBinTree RESULT = null;
		int eleft = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right;
		SLexeme e = (SLexeme)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).value;
		 RESULT = handleTerm( e ); 
              CUP$SEparser$result = new java_cup.runtime.Symbol(2/*S_EXPR*/, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, RESULT);
            }
          return CUP$SEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // S_EXPR ::= BeginHat LINE EndHat 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-2)).right;
		SLexeme e1 = (SLexeme)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).right;
		HighLevelBinTree e2 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).value;
		 RESULT = handleHat( e1 , e2 ); 
              CUP$SEparser$result = new java_cup.runtime.Symbol(2/*S_EXPR*/, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, RESULT);
            }
          return CUP$SEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // S_EXPR ::= BeginTagColor NT$3 LINE EndColor 
            {
              HighLevelBinTree RESULT = null;
              // propagate RESULT from NT$3
              if ( ((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-2)).value != null )
                RESULT = (HighLevelBinTree) ((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-2)).value;
		int e1left = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-3)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-3)).right;
		SLexeme e1 = (SLexeme)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).right;
		HighLevelBinTree e = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).value;
		 colorStackPop(); RESULT = e; 
              CUP$SEparser$result = new java_cup.runtime.Symbol(2/*S_EXPR*/, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-3)).left, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, RESULT);
            }
          return CUP$SEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // NT$3 ::= 
            {
              Object RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right;
		SLexeme e1 = (SLexeme)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).value;
 colorStackPush( e1 ); 
              CUP$SEparser$result = new java_cup.runtime.Symbol(11/*NT$3*/, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, RESULT);
            }
          return CUP$SEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // S_EXPR ::= BeginCursor LINE EndCursor 
            {
              HighLevelBinTree RESULT = null;
		int eleft = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).right;
		HighLevelBinTree e = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).value;
		 RESULT = handleCursor( e ); 
              CUP$SEparser$result = new java_cup.runtime.Symbol(2/*S_EXPR*/, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, RESULT);
            }
          return CUP$SEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // S_EXPR ::= BeginBoldUp NT$2 LINE EndBoldUp 
            {
              HighLevelBinTree RESULT = null;
              // propagate RESULT from NT$2
              if ( ((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-2)).value != null )
                RESULT = (HighLevelBinTree) ((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).right;
		HighLevelBinTree e = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).value;
		 stackPop(); RESULT = e; 
              CUP$SEparser$result = new java_cup.runtime.Symbol(2/*S_EXPR*/, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-3)).left, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, RESULT);
            }
          return CUP$SEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // NT$2 ::= 
            {
              Object RESULT = null;
 stackPushBoldUp(); 
              CUP$SEparser$result = new java_cup.runtime.Symbol(10/*NT$2*/, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, RESULT);
            }
          return CUP$SEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // S_EXPR ::= BeginUpright NT$1 LINE EndUpright 
            {
              HighLevelBinTree RESULT = null;
              // propagate RESULT from NT$1
              if ( ((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-2)).value != null )
                RESULT = (HighLevelBinTree) ((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).right;
		HighLevelBinTree e = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).value;
		 stackPop(); RESULT = e; 
              CUP$SEparser$result = new java_cup.runtime.Symbol(2/*S_EXPR*/, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-3)).left, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, RESULT);
            }
          return CUP$SEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // NT$1 ::= 
            {
              Object RESULT = null;
 stackPushUp(); 
              CUP$SEparser$result = new java_cup.runtime.Symbol(9/*NT$1*/, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, RESULT);
            }
          return CUP$SEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // S_EXPR ::= BeginBold NT$0 LINE EndBold 
            {
              HighLevelBinTree RESULT = null;
              // propagate RESULT from NT$0
              if ( ((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-2)).value != null )
                RESULT = (HighLevelBinTree) ((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).right;
		HighLevelBinTree e = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).value;
		 stackPop(); RESULT = e; 
              CUP$SEparser$result = new java_cup.runtime.Symbol(2/*S_EXPR*/, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-3)).left, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, RESULT);
            }
          return CUP$SEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // NT$0 ::= 
            {
              Object RESULT = null;
 stackPushBold(); 
              CUP$SEparser$result = new java_cup.runtime.Symbol(8/*NT$0*/, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, RESULT);
            }
          return CUP$SEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // S_EXPR ::= BeginApply LINE EndApply 
            {
              HighLevelBinTree RESULT = null;
		int eleft = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).right;
		HighLevelBinTree e = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).value;
		 RESULT = e; 
              CUP$SEparser$result = new java_cup.runtime.Symbol(2/*S_EXPR*/, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, RESULT);
            }
          return CUP$SEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // S_EXPR ::= BeginBox LINE EndBox 
            {
              HighLevelBinTree RESULT = null;
		int eleft = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).right;
		HighLevelBinTree e = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).value;
		 RESULT = e; 
              CUP$SEparser$result = new java_cup.runtime.Symbol(2/*S_EXPR*/, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-2)).left, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, RESULT);
            }
          return CUP$SEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // L_EXPR ::= S_EXPR MODIFIER_LIST 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).right;
		HighLevelBinTree e1 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right;
		HighLevelBinTree e2 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).value;
		 RESULT = mergeLexpr( e1 , e2 ); 
              CUP$SEparser$result = new java_cup.runtime.Symbol(6/*L_EXPR*/, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, RESULT);
            }
          return CUP$SEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // L_EXPR ::= S_EXPR 
            {
              HighLevelBinTree RESULT = null;
		int eleft = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right;
		HighLevelBinTree e = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).value;
		 RESULT = e; 
              CUP$SEparser$result = new java_cup.runtime.Symbol(6/*L_EXPR*/, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, RESULT);
            }
          return CUP$SEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // T_EXPR ::= T_EXPR L_EXPR 
            {
              HighLevelBinTree RESULT = null;
		int e1left = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).right;
		HighLevelBinTree e1 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right;
		HighLevelBinTree e2 = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).value;
		 RESULT = mergeExpr( e1 , e2 ); 
              CUP$SEparser$result = new java_cup.runtime.Symbol(7/*T_EXPR*/, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, RESULT);
            }
          return CUP$SEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // T_EXPR ::= L_EXPR 
            {
              HighLevelBinTree RESULT = null;
		int eleft = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right;
		HighLevelBinTree e = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).value;
		 RESULT = e; 
              CUP$SEparser$result = new java_cup.runtime.Symbol(7/*T_EXPR*/, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, RESULT);
            }
          return CUP$SEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // EXPR ::= T_EXPR 
            {
              HighLevelBinTree RESULT = null;
		int eleft = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right;
		HighLevelBinTree e = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).value;
		 RESULT = finalMergeExpr( e ); 
              CUP$SEparser$result = new java_cup.runtime.Symbol(5/*EXPR*/, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, RESULT);
            }
          return CUP$SEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // LINE ::= 
            {
              HighLevelBinTree RESULT = null;
		 RESULT = new HighLevelBinTree(); 
              CUP$SEparser$result = new java_cup.runtime.Symbol(1/*LINE*/, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, RESULT);
            }
          return CUP$SEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // $START ::= LINE EOF 
            {
              Object RESULT = null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).right;
		HighLevelBinTree start_val = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).value;
		RESULT = start_val;
              CUP$SEparser$result = new java_cup.runtime.Symbol(0/*$START*/, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-1)).left, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, RESULT);
            }
          /* ACCEPT */
          CUP$SEparser$parser.done_parsing();
          return CUP$SEparser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // LINE ::= EXPR 
            {
              HighLevelBinTree RESULT = null;
		int eleft = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right;
		HighLevelBinTree e = (HighLevelBinTree)((java_cup.runtime.Symbol) CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).value;
		 RESULT = e; 
              CUP$SEparser$result = new java_cup.runtime.Symbol(1/*LINE*/, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).left, ((java_cup.runtime.Symbol)CUP$SEparser$stack.elementAt(CUP$SEparser$top-0)).right, RESULT);
            }
          return CUP$SEparser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

